// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: witness.proto

#ifndef PROTOBUF_witness_2eproto__INCLUDED
#define PROTOBUF_witness_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "system.pb.h"
// @@protoc_insertion_point(includes)

namespace dg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_witness_2eproto();
void protobuf_AssignDesc_witness_2eproto();
void protobuf_ShutdownFile_witness_2eproto();

class LicensePlate;
class RecognizedFace;
class RecognizedVehicle;
class Scene;
class Symbol;
class SymbolItem;
class VehicleModel;
class WitnessBatchRequest;
class WitnessBatchResponse;
class WitnessImage;
class WitnessRequest;
class WitnessRequestContext;
class WitnessResponse;
class WitnessResponseContext;
class WitnessResult;

enum WitnessFunction {
  REC_FUNC_DEFAULT = 0,
  REC_FUNC_DETECTION = 1,
  REC_FUNC_FEATURE = 2,
  WitnessFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WitnessFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WitnessFunction_IsValid(int value);
const WitnessFunction WitnessFunction_MIN = REC_FUNC_DEFAULT;
const WitnessFunction WitnessFunction_MAX = REC_FUNC_FEATURE;
const int WitnessFunction_ARRAYSIZE = WitnessFunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* WitnessFunction_descriptor();
inline const ::std::string& WitnessFunction_Name(WitnessFunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    WitnessFunction_descriptor(), value);
}
inline bool WitnessFunction_Parse(
    const ::std::string& name, WitnessFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WitnessFunction>(
    WitnessFunction_descriptor(), name, value);
}
// ===================================================================

class WitnessRequest : public ::google::protobuf::Message {
 public:
  WitnessRequest();
  virtual ~WitnessRequest();

  WitnessRequest(const WitnessRequest& from);

  inline WitnessRequest& operator=(const WitnessRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessRequest& default_instance();

  void Swap(WitnessRequest* other);

  // implements Message ----------------------------------------------

  inline WitnessRequest* New() const { return New(NULL); }

  WitnessRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessRequest& from);
  void MergeFrom(const WitnessRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.WitnessRequestContext Context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::dg::WitnessRequestContext& context() const;
  ::dg::WitnessRequestContext* mutable_context();
  ::dg::WitnessRequestContext* release_context();
  void set_allocated_context(::dg::WitnessRequestContext* context);

  // optional .dg.WitnessImage Image = 2;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::dg::WitnessImage& image() const;
  ::dg::WitnessImage* mutable_image();
  ::dg::WitnessImage* release_image();
  void set_allocated_image(::dg::WitnessImage* image);

  // @@protoc_insertion_point(class_scope:dg.WitnessRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::WitnessRequestContext* context_;
  ::dg::WitnessImage* image_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessRequest* default_instance_;
};
// -------------------------------------------------------------------

class WitnessBatchRequest : public ::google::protobuf::Message {
 public:
  WitnessBatchRequest();
  virtual ~WitnessBatchRequest();

  WitnessBatchRequest(const WitnessBatchRequest& from);

  inline WitnessBatchRequest& operator=(const WitnessBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessBatchRequest& default_instance();

  void Swap(WitnessBatchRequest* other);

  // implements Message ----------------------------------------------

  inline WitnessBatchRequest* New() const { return New(NULL); }

  WitnessBatchRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessBatchRequest& from);
  void MergeFrom(const WitnessBatchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessBatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.WitnessRequestContext Context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::dg::WitnessRequestContext& context() const;
  ::dg::WitnessRequestContext* mutable_context();
  ::dg::WitnessRequestContext* release_context();
  void set_allocated_context(::dg::WitnessRequestContext* context);

  // repeated .dg.WitnessImage Images = 2;
  int images_size() const;
  void clear_images();
  static const int kImagesFieldNumber = 2;
  const ::dg::WitnessImage& images(int index) const;
  ::dg::WitnessImage* mutable_images(int index);
  ::dg::WitnessImage* add_images();
  ::google::protobuf::RepeatedPtrField< ::dg::WitnessImage >*
      mutable_images();
  const ::google::protobuf::RepeatedPtrField< ::dg::WitnessImage >&
      images() const;

  // @@protoc_insertion_point(class_scope:dg.WitnessBatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::WitnessRequestContext* context_;
  ::google::protobuf::RepeatedPtrField< ::dg::WitnessImage > images_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessBatchRequest* default_instance_;
};
// -------------------------------------------------------------------

class WitnessResponse : public ::google::protobuf::Message {
 public:
  WitnessResponse();
  virtual ~WitnessResponse();

  WitnessResponse(const WitnessResponse& from);

  inline WitnessResponse& operator=(const WitnessResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessResponse& default_instance();

  void Swap(WitnessResponse* other);

  // implements Message ----------------------------------------------

  inline WitnessResponse* New() const { return New(NULL); }

  WitnessResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessResponse& from);
  void MergeFrom(const WitnessResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.WitnessResponseContext Context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::dg::WitnessResponseContext& context() const;
  ::dg::WitnessResponseContext* mutable_context();
  ::dg::WitnessResponseContext* release_context();
  void set_allocated_context(::dg::WitnessResponseContext* context);

  // optional .dg.WitnessResult Result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  const ::dg::WitnessResult& result() const;
  ::dg::WitnessResult* mutable_result();
  ::dg::WitnessResult* release_result();
  void set_allocated_result(::dg::WitnessResult* result);

  // @@protoc_insertion_point(class_scope:dg.WitnessResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::WitnessResponseContext* context_;
  ::dg::WitnessResult* result_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessResponse* default_instance_;
};
// -------------------------------------------------------------------

class WitnessBatchResponse : public ::google::protobuf::Message {
 public:
  WitnessBatchResponse();
  virtual ~WitnessBatchResponse();

  WitnessBatchResponse(const WitnessBatchResponse& from);

  inline WitnessBatchResponse& operator=(const WitnessBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessBatchResponse& default_instance();

  void Swap(WitnessBatchResponse* other);

  // implements Message ----------------------------------------------

  inline WitnessBatchResponse* New() const { return New(NULL); }

  WitnessBatchResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessBatchResponse& from);
  void MergeFrom(const WitnessBatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessBatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.WitnessResponseContext Context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::dg::WitnessResponseContext& context() const;
  ::dg::WitnessResponseContext* mutable_context();
  ::dg::WitnessResponseContext* release_context();
  void set_allocated_context(::dg::WitnessResponseContext* context);

  // repeated .dg.WitnessResult Results = 2;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 2;
  const ::dg::WitnessResult& results(int index) const;
  ::dg::WitnessResult* mutable_results(int index);
  ::dg::WitnessResult* add_results();
  ::google::protobuf::RepeatedPtrField< ::dg::WitnessResult >*
      mutable_results();
  const ::google::protobuf::RepeatedPtrField< ::dg::WitnessResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:dg.WitnessBatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::WitnessResponseContext* context_;
  ::google::protobuf::RepeatedPtrField< ::dg::WitnessResult > results_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessBatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class WitnessRequestContext : public ::google::protobuf::Message {
 public:
  WitnessRequestContext();
  virtual ~WitnessRequestContext();

  WitnessRequestContext(const WitnessRequestContext& from);

  inline WitnessRequestContext& operator=(const WitnessRequestContext& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessRequestContext& default_instance();

  void Swap(WitnessRequestContext* other);

  // implements Message ----------------------------------------------

  inline WitnessRequestContext* New() const { return New(NULL); }

  WitnessRequestContext* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessRequestContext& from);
  void MergeFrom(const WitnessRequestContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessRequestContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string SessionId = 1;
  void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // repeated .dg.WitnessFunction Functions = 4;
  int functions_size() const;
  void clear_functions();
  static const int kFunctionsFieldNumber = 4;
  ::dg::WitnessFunction functions(int index) const;
  void set_functions(int index, ::dg::WitnessFunction value);
  void add_functions(::dg::WitnessFunction value);
  const ::google::protobuf::RepeatedField<int>& functions() const;
  ::google::protobuf::RepeatedField<int>* mutable_functions();

  // optional .dg.RecognizeType Type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::dg::RecognizeType type() const;
  void set_type(::dg::RecognizeType value);

  // optional .dg.StorageConfig Storage = 6;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 6;
  const ::dg::StorageConfig& storage() const;
  ::dg::StorageConfig* mutable_storage();
  ::dg::StorageConfig* release_storage();
  void set_allocated_storage(::dg::StorageConfig* storage);

  // map<string, string> Params = 7;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 7;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_params();

  // @@protoc_insertion_point(class_scope:dg.WitnessRequestContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::google::protobuf::RepeatedField<int> functions_;
  mutable int _functions_cached_byte_size_;
  ::dg::StorageConfig* storage_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 >
      WitnessRequestContext_ParamsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > params_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessRequestContext* default_instance_;
};
// -------------------------------------------------------------------

class WitnessImage : public ::google::protobuf::Message {
 public:
  WitnessImage();
  virtual ~WitnessImage();

  WitnessImage(const WitnessImage& from);

  inline WitnessImage& operator=(const WitnessImage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessImage& default_instance();

  void Swap(WitnessImage* other);

  // implements Message ----------------------------------------------

  inline WitnessImage* New() const { return New(NULL); }

  WitnessImage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessImage& from);
  void MergeFrom(const WitnessImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.Image Data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::dg::Image& data() const;
  ::dg::Image* mutable_data();
  ::dg::Image* release_data();
  void set_allocated_data(::dg::Image* data);

  // optional int32 SensorId = 2;
  void clear_sensorid();
  static const int kSensorIdFieldNumber = 2;
  ::google::protobuf::int32 sensorid() const;
  void set_sensorid(::google::protobuf::int32 value);

  // optional string SensorName = 3;
  void clear_sensorname();
  static const int kSensorNameFieldNumber = 3;
  const ::std::string& sensorname() const;
  void set_sensorname(const ::std::string& value);
  void set_sensorname(const char* value);
  void set_sensorname(const char* value, size_t size);
  ::std::string* mutable_sensorname();
  ::std::string* release_sensorname();
  void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:dg.WitnessImage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::Image* data_;
  ::google::protobuf::internal::ArenaStringPtr sensorname_;
  ::google::protobuf::int32 sensorid_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessImage* default_instance_;
};
// -------------------------------------------------------------------

class WitnessResponseContext : public ::google::protobuf::Message {
 public:
  WitnessResponseContext();
  virtual ~WitnessResponseContext();

  WitnessResponseContext(const WitnessResponseContext& from);

  inline WitnessResponseContext& operator=(const WitnessResponseContext& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessResponseContext& default_instance();

  void Swap(WitnessResponseContext* other);

  // implements Message ----------------------------------------------

  inline WitnessResponseContext* New() const { return New(NULL); }

  WitnessResponseContext* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessResponseContext& from);
  void MergeFrom(const WitnessResponseContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessResponseContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string SessionId = 1;
  void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // optional string Status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // optional string Message = 3;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .dg.Time RequestTs = 4;
  bool has_requestts() const;
  void clear_requestts();
  static const int kRequestTsFieldNumber = 4;
  const ::dg::Time& requestts() const;
  ::dg::Time* mutable_requestts();
  ::dg::Time* release_requestts();
  void set_allocated_requestts(::dg::Time* requestts);

  // optional .dg.Time ResponseTs = 5;
  bool has_responsets() const;
  void clear_responsets();
  static const int kResponseTsFieldNumber = 5;
  const ::dg::Time& responsets() const;
  ::dg::Time* mutable_responsets();
  ::dg::Time* release_responsets();
  void set_allocated_responsets(::dg::Time* responsets);

  // map<string, .dg.Time> DebugTs = 6;
  int debugts_size() const;
  void clear_debugts();
  static const int kDebugTsFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::dg::Time >&
      debugts() const;
  ::google::protobuf::Map< ::std::string, ::dg::Time >*
      mutable_debugts();

  // @@protoc_insertion_point(class_scope:dg.WitnessResponseContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::dg::Time* requestts_;
  ::dg::Time* responsets_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::dg::Time,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      WitnessResponseContext_DebugTsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::dg::Time,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > debugts_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessResponseContext* default_instance_;
};
// -------------------------------------------------------------------

class WitnessResult : public ::google::protobuf::Message {
 public:
  WitnessResult();
  virtual ~WitnessResult();

  WitnessResult(const WitnessResult& from);

  inline WitnessResult& operator=(const WitnessResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessResult& default_instance();

  void Swap(WitnessResult* other);

  // implements Message ----------------------------------------------

  inline WitnessResult* New() const { return New(NULL); }

  WitnessResult* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WitnessResult& from);
  void MergeFrom(const WitnessResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WitnessResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string InnerStatus = 1;
  void clear_innerstatus();
  static const int kInnerStatusFieldNumber = 1;
  const ::std::string& innerstatus() const;
  void set_innerstatus(const ::std::string& value);
  void set_innerstatus(const char* value);
  void set_innerstatus(const char* value, size_t size);
  ::std::string* mutable_innerstatus();
  ::std::string* release_innerstatus();
  void set_allocated_innerstatus(::std::string* innerstatus);

  // optional string InnerMessage = 2;
  void clear_innermessage();
  static const int kInnerMessageFieldNumber = 2;
  const ::std::string& innermessage() const;
  void set_innermessage(const ::std::string& value);
  void set_innermessage(const char* value);
  void set_innermessage(const char* value, size_t size);
  ::std::string* mutable_innermessage();
  ::std::string* release_innermessage();
  void set_allocated_innermessage(::std::string* innermessage);

  // optional .dg.WitnessImage Image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::dg::WitnessImage& image() const;
  ::dg::WitnessImage* mutable_image();
  ::dg::WitnessImage* release_image();
  void set_allocated_image(::dg::WitnessImage* image);

  // repeated .dg.RecognizedVehicle Vehicles = 4;
  int vehicles_size() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 4;
  const ::dg::RecognizedVehicle& vehicles(int index) const;
  ::dg::RecognizedVehicle* mutable_vehicles(int index);
  ::dg::RecognizedVehicle* add_vehicles();
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizedVehicle >*
      mutable_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::dg::RecognizedVehicle >&
      vehicles() const;

  // repeated .dg.RecognizedFace Faces = 5;
  int faces_size() const;
  void clear_faces();
  static const int kFacesFieldNumber = 5;
  const ::dg::RecognizedFace& faces(int index) const;
  ::dg::RecognizedFace* mutable_faces(int index);
  ::dg::RecognizedFace* add_faces();
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizedFace >*
      mutable_faces();
  const ::google::protobuf::RepeatedPtrField< ::dg::RecognizedFace >&
      faces() const;

  // @@protoc_insertion_point(class_scope:dg.WitnessResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr innerstatus_;
  ::google::protobuf::internal::ArenaStringPtr innermessage_;
  ::dg::WitnessImage* image_;
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizedVehicle > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizedFace > faces_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static WitnessResult* default_instance_;
};
// -------------------------------------------------------------------

class RecognizedVehicle : public ::google::protobuf::Message {
 public:
  RecognizedVehicle();
  virtual ~RecognizedVehicle();

  RecognizedVehicle(const RecognizedVehicle& from);

  inline RecognizedVehicle& operator=(const RecognizedVehicle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizedVehicle& default_instance();

  void Swap(RecognizedVehicle* other);

  // implements Message ----------------------------------------------

  inline RecognizedVehicle* New() const { return New(NULL); }

  RecognizedVehicle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizedVehicle& from);
  void MergeFrom(const RecognizedVehicle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizedVehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.VehicleModel Model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::dg::VehicleModel& model() const;
  ::dg::VehicleModel* mutable_model();
  ::dg::VehicleModel* release_model();
  void set_allocated_model(::dg::VehicleModel* model);

  // optional .dg.Cutboard Cutboard = 2;
  bool has_cutboard() const;
  void clear_cutboard();
  static const int kCutboardFieldNumber = 2;
  const ::dg::Cutboard& cutboard() const;
  ::dg::Cutboard* mutable_cutboard();
  ::dg::Cutboard* release_cutboard();
  void set_allocated_cutboard(::dg::Cutboard* cutboard);

  // optional .dg.Color Color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  const ::dg::Color& color() const;
  ::dg::Color* mutable_color();
  ::dg::Color* release_color();
  void set_allocated_color(::dg::Color* color);

  // optional .dg.LicensePlate LicensePlate = 4;
  bool has_licenseplate() const;
  void clear_licenseplate();
  static const int kLicensePlateFieldNumber = 4;
  const ::dg::LicensePlate& licenseplate() const;
  ::dg::LicensePlate* mutable_licenseplate();
  ::dg::LicensePlate* release_licenseplate();
  void set_allocated_licenseplate(::dg::LicensePlate* licenseplate);

  // repeated .dg.SymbolItem SymbolItems = 5;
  int symbolitems_size() const;
  void clear_symbolitems();
  static const int kSymbolItemsFieldNumber = 5;
  const ::dg::SymbolItem& symbolitems(int index) const;
  ::dg::SymbolItem* mutable_symbolitems(int index);
  ::dg::SymbolItem* add_symbolitems();
  ::google::protobuf::RepeatedPtrField< ::dg::SymbolItem >*
      mutable_symbolitems();
  const ::google::protobuf::RepeatedPtrField< ::dg::SymbolItem >&
      symbolitems() const;

  // repeated .dg.VehicleModel Candidates = 6;
  int candidates_size() const;
  void clear_candidates();
  static const int kCandidatesFieldNumber = 6;
  const ::dg::VehicleModel& candidates(int index) const;
  ::dg::VehicleModel* mutable_candidates(int index);
  ::dg::VehicleModel* add_candidates();
  ::google::protobuf::RepeatedPtrField< ::dg::VehicleModel >*
      mutable_candidates();
  const ::google::protobuf::RepeatedPtrField< ::dg::VehicleModel >&
      candidates() const;

  // optional string Features = 7;
  void clear_features();
  static const int kFeaturesFieldNumber = 7;
  const ::std::string& features() const;
  void set_features(const ::std::string& value);
  void set_features(const char* value);
  void set_features(const char* value, size_t size);
  ::std::string* mutable_features();
  ::std::string* release_features();
  void set_allocated_features(::std::string* features);

  // optional .dg.Scene Scene = 8;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 8;
  const ::dg::Scene& scene() const;
  ::dg::Scene* mutable_scene();
  ::dg::Scene* release_scene();
  void set_allocated_scene(::dg::Scene* scene);

  // @@protoc_insertion_point(class_scope:dg.RecognizedVehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::VehicleModel* model_;
  ::dg::Cutboard* cutboard_;
  ::dg::Color* color_;
  ::dg::LicensePlate* licenseplate_;
  ::google::protobuf::RepeatedPtrField< ::dg::SymbolItem > symbolitems_;
  ::google::protobuf::RepeatedPtrField< ::dg::VehicleModel > candidates_;
  ::google::protobuf::internal::ArenaStringPtr features_;
  ::dg::Scene* scene_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizedVehicle* default_instance_;
};
// -------------------------------------------------------------------

class RecognizedFace : public ::google::protobuf::Message {
 public:
  RecognizedFace();
  virtual ~RecognizedFace();

  RecognizedFace(const RecognizedFace& from);

  inline RecognizedFace& operator=(const RecognizedFace& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizedFace& default_instance();

  void Swap(RecognizedFace* other);

  // implements Message ----------------------------------------------

  inline RecognizedFace* New() const { return New(NULL); }

  RecognizedFace* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizedFace& from);
  void MergeFrom(const RecognizedFace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizedFace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.Cutboard Cutboard = 1;
  bool has_cutboard() const;
  void clear_cutboard();
  static const int kCutboardFieldNumber = 1;
  const ::dg::Cutboard& cutboard() const;
  ::dg::Cutboard* mutable_cutboard();
  ::dg::Cutboard* release_cutboard();
  void set_allocated_cutboard(::dg::Cutboard* cutboard);

  // optional float Confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  float confidence() const;
  void set_confidence(float value);

  // optional string Features = 3;
  void clear_features();
  static const int kFeaturesFieldNumber = 3;
  const ::std::string& features() const;
  void set_features(const ::std::string& value);
  void set_features(const char* value);
  void set_features(const char* value, size_t size);
  ::std::string* mutable_features();
  ::std::string* release_features();
  void set_allocated_features(::std::string* features);

  // @@protoc_insertion_point(class_scope:dg.RecognizedFace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::Cutboard* cutboard_;
  ::google::protobuf::internal::ArenaStringPtr features_;
  float confidence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizedFace* default_instance_;
};
// -------------------------------------------------------------------

class VehicleModel : public ::google::protobuf::Message {
 public:
  VehicleModel();
  virtual ~VehicleModel();

  VehicleModel(const VehicleModel& from);

  inline VehicleModel& operator=(const VehicleModel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleModel& default_instance();

  void Swap(VehicleModel* other);

  // implements Message ----------------------------------------------

  inline VehicleModel* New() const { return New(NULL); }

  VehicleModel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleModel& from);
  void MergeFrom(const VehicleModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 TypeId = 1;
  void clear_typeid_();
  static const int kTypeIdFieldNumber = 1;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // optional int32 BrandId = 2;
  void clear_brandid();
  static const int kBrandIdFieldNumber = 2;
  ::google::protobuf::int32 brandid() const;
  void set_brandid(::google::protobuf::int32 value);

  // optional int32 SubBrandId = 3;
  void clear_subbrandid();
  static const int kSubBrandIdFieldNumber = 3;
  ::google::protobuf::int32 subbrandid() const;
  void set_subbrandid(::google::protobuf::int32 value);

  // optional int32 ModelYearId = 4;
  void clear_modelyearid();
  static const int kModelYearIdFieldNumber = 4;
  ::google::protobuf::int32 modelyearid() const;
  void set_modelyearid(::google::protobuf::int32 value);

  // optional string Type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string Brand = 6;
  void clear_brand();
  static const int kBrandFieldNumber = 6;
  const ::std::string& brand() const;
  void set_brand(const ::std::string& value);
  void set_brand(const char* value);
  void set_brand(const char* value, size_t size);
  ::std::string* mutable_brand();
  ::std::string* release_brand();
  void set_allocated_brand(::std::string* brand);

  // optional string SubBrand = 7;
  void clear_subbrand();
  static const int kSubBrandFieldNumber = 7;
  const ::std::string& subbrand() const;
  void set_subbrand(const ::std::string& value);
  void set_subbrand(const char* value);
  void set_subbrand(const char* value, size_t size);
  ::std::string* mutable_subbrand();
  ::std::string* release_subbrand();
  void set_allocated_subbrand(::std::string* subbrand);

  // optional string ModelYear = 8;
  void clear_modelyear();
  static const int kModelYearFieldNumber = 8;
  const ::std::string& modelyear() const;
  void set_modelyear(const ::std::string& value);
  void set_modelyear(const char* value);
  void set_modelyear(const char* value, size_t size);
  ::std::string* mutable_modelyear();
  ::std::string* release_modelyear();
  void set_allocated_modelyear(::std::string* modelyear);

  // optional int32 IsHead = 9;
  void clear_ishead();
  static const int kIsHeadFieldNumber = 9;
  ::google::protobuf::int32 ishead() const;
  void set_ishead(::google::protobuf::int32 value);

  // optional float Confidence = 10;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 10;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:dg.VehicleModel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 brandid_;
  ::google::protobuf::int32 subbrandid_;
  ::google::protobuf::int32 modelyearid_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr brand_;
  ::google::protobuf::internal::ArenaStringPtr subbrand_;
  ::google::protobuf::internal::ArenaStringPtr modelyear_;
  ::google::protobuf::int32 ishead_;
  float confidence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static VehicleModel* default_instance_;
};
// -------------------------------------------------------------------

class LicensePlate : public ::google::protobuf::Message {
 public:
  LicensePlate();
  virtual ~LicensePlate();

  LicensePlate(const LicensePlate& from);

  inline LicensePlate& operator=(const LicensePlate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LicensePlate& default_instance();

  void Swap(LicensePlate* other);

  // implements Message ----------------------------------------------

  inline LicensePlate* New() const { return New(NULL); }

  LicensePlate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LicensePlate& from);
  void MergeFrom(const LicensePlate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LicensePlate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string PlateNum = 1;
  void clear_platenum();
  static const int kPlateNumFieldNumber = 1;
  const ::std::string& platenum() const;
  void set_platenum(const ::std::string& value);
  void set_platenum(const char* value);
  void set_platenum(const char* value, size_t size);
  ::std::string* mutable_platenum();
  ::std::string* release_platenum();
  void set_allocated_platenum(::std::string* platenum);

  // optional .dg.Cutboard Cutboard = 2;
  bool has_cutboard() const;
  void clear_cutboard();
  static const int kCutboardFieldNumber = 2;
  const ::dg::Cutboard& cutboard() const;
  ::dg::Cutboard* mutable_cutboard();
  ::dg::Cutboard* release_cutboard();
  void set_allocated_cutboard(::dg::Cutboard* cutboard);

  // optional int32 ColorId = 3;
  void clear_colorid();
  static const int kColorIdFieldNumber = 3;
  ::google::protobuf::int32 colorid() const;
  void set_colorid(::google::protobuf::int32 value);

  // optional string Color = 4;
  void clear_color();
  static const int kColorFieldNumber = 4;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // optional int32 TypeId = 5;
  void clear_typeid_();
  static const int kTypeIdFieldNumber = 5;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // optional string Type = 6;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional float Confidence = 7;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 7;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:dg.LicensePlate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr platenum_;
  ::dg::Cutboard* cutboard_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::google::protobuf::int32 colorid_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::internal::ArenaStringPtr type_;
  float confidence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static LicensePlate* default_instance_;
};
// -------------------------------------------------------------------

class SymbolItem : public ::google::protobuf::Message {
 public:
  SymbolItem();
  virtual ~SymbolItem();

  SymbolItem(const SymbolItem& from);

  inline SymbolItem& operator=(const SymbolItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolItem& default_instance();

  void Swap(SymbolItem* other);

  // implements Message ----------------------------------------------

  inline SymbolItem* New() const { return New(NULL); }

  SymbolItem* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolItem& from);
  void MergeFrom(const SymbolItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SymbolItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 SymbolId = 1;
  void clear_symbolid();
  static const int kSymbolIdFieldNumber = 1;
  ::google::protobuf::int32 symbolid() const;
  void set_symbolid(::google::protobuf::int32 value);

  // optional string SymbolName = 2;
  void clear_symbolname();
  static const int kSymbolNameFieldNumber = 2;
  const ::std::string& symbolname() const;
  void set_symbolname(const ::std::string& value);
  void set_symbolname(const char* value);
  void set_symbolname(const char* value, size_t size);
  ::std::string* mutable_symbolname();
  ::std::string* release_symbolname();
  void set_allocated_symbolname(::std::string* symbolname);

  // repeated .dg.Symbol Symbols = 3;
  int symbols_size() const;
  void clear_symbols();
  static const int kSymbolsFieldNumber = 3;
  const ::dg::Symbol& symbols(int index) const;
  ::dg::Symbol* mutable_symbols(int index);
  ::dg::Symbol* add_symbols();
  ::google::protobuf::RepeatedPtrField< ::dg::Symbol >*
      mutable_symbols();
  const ::google::protobuf::RepeatedPtrField< ::dg::Symbol >&
      symbols() const;

  // @@protoc_insertion_point(class_scope:dg.SymbolItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr symbolname_;
  ::google::protobuf::RepeatedPtrField< ::dg::Symbol > symbols_;
  ::google::protobuf::int32 symbolid_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static SymbolItem* default_instance_;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  inline Scene* New() const { return New(NULL); }

  Scene* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Scene* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 IsHead = 1;
  void clear_ishead();
  static const int kIsHeadFieldNumber = 1;
  ::google::protobuf::int32 ishead() const;
  void set_ishead(::google::protobuf::int32 value);

  // optional int32 IsDay = 2;
  void clear_isday();
  static const int kIsDayFieldNumber = 2;
  ::google::protobuf::int32 isday() const;
  void set_isday(::google::protobuf::int32 value);

  // optional string Border = 3;
  void clear_border();
  static const int kBorderFieldNumber = 3;
  const ::std::string& border() const;
  void set_border(const ::std::string& value);
  void set_border(const char* value);
  void set_border(const char* value, size_t size);
  ::std::string* mutable_border();
  ::std::string* release_border();
  void set_allocated_border(::std::string* border);

  // @@protoc_insertion_point(class_scope:dg.Scene)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 ishead_;
  ::google::protobuf::int32 isday_;
  ::google::protobuf::internal::ArenaStringPtr border_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static Scene* default_instance_;
};
// -------------------------------------------------------------------

class Symbol : public ::google::protobuf::Message {
 public:
  Symbol();
  virtual ~Symbol();

  Symbol(const Symbol& from);

  inline Symbol& operator=(const Symbol& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Symbol& default_instance();

  void Swap(Symbol* other);

  // implements Message ----------------------------------------------

  inline Symbol* New() const { return New(NULL); }

  Symbol* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Symbol& from);
  void MergeFrom(const Symbol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Symbol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.Cutboard Cutboard = 3;
  bool has_cutboard() const;
  void clear_cutboard();
  static const int kCutboardFieldNumber = 3;
  const ::dg::Cutboard& cutboard() const;
  ::dg::Cutboard* mutable_cutboard();
  ::dg::Cutboard* release_cutboard();
  void set_allocated_cutboard(::dg::Cutboard* cutboard);

  // optional float Confidence = 4;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:dg.Symbol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::Cutboard* cutboard_;
  float confidence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static Symbol* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// WitnessRequest

// optional .dg.WitnessRequestContext Context = 1;
inline bool WitnessRequest::has_context() const {
  return !_is_default_instance_ && context_ != NULL;
}
inline void WitnessRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) delete context_;
  context_ = NULL;
}
inline const ::dg::WitnessRequestContext& WitnessRequest::context() const {
  // @@protoc_insertion_point(field_get:dg.WitnessRequest.Context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::dg::WitnessRequestContext* WitnessRequest::mutable_context() {
  
  if (context_ == NULL) {
    context_ = new ::dg::WitnessRequestContext;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessRequest.Context)
  return context_;
}
inline ::dg::WitnessRequestContext* WitnessRequest::release_context() {
  
  ::dg::WitnessRequestContext* temp = context_;
  context_ = NULL;
  return temp;
}
inline void WitnessRequest::set_allocated_context(::dg::WitnessRequestContext* context) {
  delete context_;
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessRequest.Context)
}

// optional .dg.WitnessImage Image = 2;
inline bool WitnessRequest::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
inline void WitnessRequest::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::dg::WitnessImage& WitnessRequest::image() const {
  // @@protoc_insertion_point(field_get:dg.WitnessRequest.Image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::dg::WitnessImage* WitnessRequest::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::dg::WitnessImage;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessRequest.Image)
  return image_;
}
inline ::dg::WitnessImage* WitnessRequest::release_image() {
  
  ::dg::WitnessImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void WitnessRequest::set_allocated_image(::dg::WitnessImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessRequest.Image)
}

// -------------------------------------------------------------------

// WitnessBatchRequest

// optional .dg.WitnessRequestContext Context = 1;
inline bool WitnessBatchRequest::has_context() const {
  return !_is_default_instance_ && context_ != NULL;
}
inline void WitnessBatchRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) delete context_;
  context_ = NULL;
}
inline const ::dg::WitnessRequestContext& WitnessBatchRequest::context() const {
  // @@protoc_insertion_point(field_get:dg.WitnessBatchRequest.Context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::dg::WitnessRequestContext* WitnessBatchRequest::mutable_context() {
  
  if (context_ == NULL) {
    context_ = new ::dg::WitnessRequestContext;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessBatchRequest.Context)
  return context_;
}
inline ::dg::WitnessRequestContext* WitnessBatchRequest::release_context() {
  
  ::dg::WitnessRequestContext* temp = context_;
  context_ = NULL;
  return temp;
}
inline void WitnessBatchRequest::set_allocated_context(::dg::WitnessRequestContext* context) {
  delete context_;
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessBatchRequest.Context)
}

// repeated .dg.WitnessImage Images = 2;
inline int WitnessBatchRequest::images_size() const {
  return images_.size();
}
inline void WitnessBatchRequest::clear_images() {
  images_.Clear();
}
inline const ::dg::WitnessImage& WitnessBatchRequest::images(int index) const {
  // @@protoc_insertion_point(field_get:dg.WitnessBatchRequest.Images)
  return images_.Get(index);
}
inline ::dg::WitnessImage* WitnessBatchRequest::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:dg.WitnessBatchRequest.Images)
  return images_.Mutable(index);
}
inline ::dg::WitnessImage* WitnessBatchRequest::add_images() {
  // @@protoc_insertion_point(field_add:dg.WitnessBatchRequest.Images)
  return images_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::WitnessImage >*
WitnessBatchRequest::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:dg.WitnessBatchRequest.Images)
  return &images_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::WitnessImage >&
WitnessBatchRequest::images() const {
  // @@protoc_insertion_point(field_list:dg.WitnessBatchRequest.Images)
  return images_;
}

// -------------------------------------------------------------------

// WitnessResponse

// optional .dg.WitnessResponseContext Context = 1;
inline bool WitnessResponse::has_context() const {
  return !_is_default_instance_ && context_ != NULL;
}
inline void WitnessResponse::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) delete context_;
  context_ = NULL;
}
inline const ::dg::WitnessResponseContext& WitnessResponse::context() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponse.Context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::dg::WitnessResponseContext* WitnessResponse::mutable_context() {
  
  if (context_ == NULL) {
    context_ = new ::dg::WitnessResponseContext;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponse.Context)
  return context_;
}
inline ::dg::WitnessResponseContext* WitnessResponse::release_context() {
  
  ::dg::WitnessResponseContext* temp = context_;
  context_ = NULL;
  return temp;
}
inline void WitnessResponse::set_allocated_context(::dg::WitnessResponseContext* context) {
  delete context_;
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponse.Context)
}

// optional .dg.WitnessResult Result = 2;
inline bool WitnessResponse::has_result() const {
  return !_is_default_instance_ && result_ != NULL;
}
inline void WitnessResponse::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) delete result_;
  result_ = NULL;
}
inline const ::dg::WitnessResult& WitnessResponse::result() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponse.Result)
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::dg::WitnessResult* WitnessResponse::mutable_result() {
  
  if (result_ == NULL) {
    result_ = new ::dg::WitnessResult;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponse.Result)
  return result_;
}
inline ::dg::WitnessResult* WitnessResponse::release_result() {
  
  ::dg::WitnessResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void WitnessResponse::set_allocated_result(::dg::WitnessResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponse.Result)
}

// -------------------------------------------------------------------

// WitnessBatchResponse

// optional .dg.WitnessResponseContext Context = 1;
inline bool WitnessBatchResponse::has_context() const {
  return !_is_default_instance_ && context_ != NULL;
}
inline void WitnessBatchResponse::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) delete context_;
  context_ = NULL;
}
inline const ::dg::WitnessResponseContext& WitnessBatchResponse::context() const {
  // @@protoc_insertion_point(field_get:dg.WitnessBatchResponse.Context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::dg::WitnessResponseContext* WitnessBatchResponse::mutable_context() {
  
  if (context_ == NULL) {
    context_ = new ::dg::WitnessResponseContext;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessBatchResponse.Context)
  return context_;
}
inline ::dg::WitnessResponseContext* WitnessBatchResponse::release_context() {
  
  ::dg::WitnessResponseContext* temp = context_;
  context_ = NULL;
  return temp;
}
inline void WitnessBatchResponse::set_allocated_context(::dg::WitnessResponseContext* context) {
  delete context_;
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessBatchResponse.Context)
}

// repeated .dg.WitnessResult Results = 2;
inline int WitnessBatchResponse::results_size() const {
  return results_.size();
}
inline void WitnessBatchResponse::clear_results() {
  results_.Clear();
}
inline const ::dg::WitnessResult& WitnessBatchResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:dg.WitnessBatchResponse.Results)
  return results_.Get(index);
}
inline ::dg::WitnessResult* WitnessBatchResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:dg.WitnessBatchResponse.Results)
  return results_.Mutable(index);
}
inline ::dg::WitnessResult* WitnessBatchResponse::add_results() {
  // @@protoc_insertion_point(field_add:dg.WitnessBatchResponse.Results)
  return results_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::WitnessResult >*
WitnessBatchResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:dg.WitnessBatchResponse.Results)
  return &results_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::WitnessResult >&
WitnessBatchResponse::results() const {
  // @@protoc_insertion_point(field_list:dg.WitnessBatchResponse.Results)
  return results_;
}

// -------------------------------------------------------------------

// WitnessRequestContext

// optional string SessionId = 1;
inline void WitnessRequestContext::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessRequestContext::sessionid() const {
  // @@protoc_insertion_point(field_get:dg.WitnessRequestContext.SessionId)
  return sessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessRequestContext::set_sessionid(const ::std::string& value) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessRequestContext.SessionId)
}
inline void WitnessRequestContext::set_sessionid(const char* value) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessRequestContext.SessionId)
}
inline void WitnessRequestContext::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessRequestContext.SessionId)
}
inline ::std::string* WitnessRequestContext::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessRequestContext.SessionId)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessRequestContext::release_sessionid() {
  
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessRequestContext::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessRequestContext.SessionId)
}

// repeated .dg.WitnessFunction Functions = 4;
inline int WitnessRequestContext::functions_size() const {
  return functions_.size();
}
inline void WitnessRequestContext::clear_functions() {
  functions_.Clear();
}
inline ::dg::WitnessFunction WitnessRequestContext::functions(int index) const {
  // @@protoc_insertion_point(field_get:dg.WitnessRequestContext.Functions)
  return static_cast< ::dg::WitnessFunction >(functions_.Get(index));
}
inline void WitnessRequestContext::set_functions(int index, ::dg::WitnessFunction value) {
  functions_.Set(index, value);
  // @@protoc_insertion_point(field_set:dg.WitnessRequestContext.Functions)
}
inline void WitnessRequestContext::add_functions(::dg::WitnessFunction value) {
  functions_.Add(value);
  // @@protoc_insertion_point(field_add:dg.WitnessRequestContext.Functions)
}
inline const ::google::protobuf::RepeatedField<int>&
WitnessRequestContext::functions() const {
  // @@protoc_insertion_point(field_list:dg.WitnessRequestContext.Functions)
  return functions_;
}
inline ::google::protobuf::RepeatedField<int>*
WitnessRequestContext::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:dg.WitnessRequestContext.Functions)
  return &functions_;
}

// optional .dg.RecognizeType Type = 5;
inline void WitnessRequestContext::clear_type() {
  type_ = 0;
}
inline ::dg::RecognizeType WitnessRequestContext::type() const {
  // @@protoc_insertion_point(field_get:dg.WitnessRequestContext.Type)
  return static_cast< ::dg::RecognizeType >(type_);
}
inline void WitnessRequestContext::set_type(::dg::RecognizeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dg.WitnessRequestContext.Type)
}

// optional .dg.StorageConfig Storage = 6;
inline bool WitnessRequestContext::has_storage() const {
  return !_is_default_instance_ && storage_ != NULL;
}
inline void WitnessRequestContext::clear_storage() {
  if (GetArenaNoVirtual() == NULL && storage_ != NULL) delete storage_;
  storage_ = NULL;
}
inline const ::dg::StorageConfig& WitnessRequestContext::storage() const {
  // @@protoc_insertion_point(field_get:dg.WitnessRequestContext.Storage)
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::dg::StorageConfig* WitnessRequestContext::mutable_storage() {
  
  if (storage_ == NULL) {
    storage_ = new ::dg::StorageConfig;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessRequestContext.Storage)
  return storage_;
}
inline ::dg::StorageConfig* WitnessRequestContext::release_storage() {
  
  ::dg::StorageConfig* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void WitnessRequestContext::set_allocated_storage(::dg::StorageConfig* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessRequestContext.Storage)
}

// map<string, string> Params = 7;
inline int WitnessRequestContext::params_size() const {
  return params_.size();
}
inline void WitnessRequestContext::clear_params() {
  params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
WitnessRequestContext::params() const {
  // @@protoc_insertion_point(field_map:dg.WitnessRequestContext.Params)
  return params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
WitnessRequestContext::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:dg.WitnessRequestContext.Params)
  return params_.MutableMap();
}

// -------------------------------------------------------------------

// WitnessImage

// optional .dg.Image Data = 1;
inline bool WitnessImage::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void WitnessImage::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::dg::Image& WitnessImage::data() const {
  // @@protoc_insertion_point(field_get:dg.WitnessImage.Data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::dg::Image* WitnessImage::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::dg::Image;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessImage.Data)
  return data_;
}
inline ::dg::Image* WitnessImage::release_data() {
  
  ::dg::Image* temp = data_;
  data_ = NULL;
  return temp;
}
inline void WitnessImage::set_allocated_data(::dg::Image* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessImage.Data)
}

// optional int32 SensorId = 2;
inline void WitnessImage::clear_sensorid() {
  sensorid_ = 0;
}
inline ::google::protobuf::int32 WitnessImage::sensorid() const {
  // @@protoc_insertion_point(field_get:dg.WitnessImage.SensorId)
  return sensorid_;
}
inline void WitnessImage::set_sensorid(::google::protobuf::int32 value) {
  
  sensorid_ = value;
  // @@protoc_insertion_point(field_set:dg.WitnessImage.SensorId)
}

// optional string SensorName = 3;
inline void WitnessImage::clear_sensorname() {
  sensorname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessImage::sensorname() const {
  // @@protoc_insertion_point(field_get:dg.WitnessImage.SensorName)
  return sensorname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessImage::set_sensorname(const ::std::string& value) {
  
  sensorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessImage.SensorName)
}
inline void WitnessImage::set_sensorname(const char* value) {
  
  sensorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessImage.SensorName)
}
inline void WitnessImage::set_sensorname(const char* value, size_t size) {
  
  sensorname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessImage.SensorName)
}
inline ::std::string* WitnessImage::mutable_sensorname() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessImage.SensorName)
  return sensorname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessImage::release_sensorname() {
  
  return sensorname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessImage::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname != NULL) {
    
  } else {
    
  }
  sensorname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensorname);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessImage.SensorName)
}

// -------------------------------------------------------------------

// WitnessResponseContext

// optional string SessionId = 1;
inline void WitnessResponseContext::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessResponseContext::sessionid() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponseContext.SessionId)
  return sessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResponseContext::set_sessionid(const ::std::string& value) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessResponseContext.SessionId)
}
inline void WitnessResponseContext::set_sessionid(const char* value) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessResponseContext.SessionId)
}
inline void WitnessResponseContext::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessResponseContext.SessionId)
}
inline ::std::string* WitnessResponseContext::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponseContext.SessionId)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessResponseContext::release_sessionid() {
  
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResponseContext::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponseContext.SessionId)
}

// optional string Status = 2;
inline void WitnessResponseContext::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessResponseContext::status() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponseContext.Status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResponseContext::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessResponseContext.Status)
}
inline void WitnessResponseContext::set_status(const char* value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessResponseContext.Status)
}
inline void WitnessResponseContext::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessResponseContext.Status)
}
inline ::std::string* WitnessResponseContext::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponseContext.Status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessResponseContext::release_status() {
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResponseContext::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponseContext.Status)
}

// optional string Message = 3;
inline void WitnessResponseContext::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessResponseContext::message() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponseContext.Message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResponseContext::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessResponseContext.Message)
}
inline void WitnessResponseContext::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessResponseContext.Message)
}
inline void WitnessResponseContext::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessResponseContext.Message)
}
inline ::std::string* WitnessResponseContext::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponseContext.Message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessResponseContext::release_message() {
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResponseContext::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponseContext.Message)
}

// optional .dg.Time RequestTs = 4;
inline bool WitnessResponseContext::has_requestts() const {
  return !_is_default_instance_ && requestts_ != NULL;
}
inline void WitnessResponseContext::clear_requestts() {
  if (GetArenaNoVirtual() == NULL && requestts_ != NULL) delete requestts_;
  requestts_ = NULL;
}
inline const ::dg::Time& WitnessResponseContext::requestts() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponseContext.RequestTs)
  return requestts_ != NULL ? *requestts_ : *default_instance_->requestts_;
}
inline ::dg::Time* WitnessResponseContext::mutable_requestts() {
  
  if (requestts_ == NULL) {
    requestts_ = new ::dg::Time;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponseContext.RequestTs)
  return requestts_;
}
inline ::dg::Time* WitnessResponseContext::release_requestts() {
  
  ::dg::Time* temp = requestts_;
  requestts_ = NULL;
  return temp;
}
inline void WitnessResponseContext::set_allocated_requestts(::dg::Time* requestts) {
  delete requestts_;
  requestts_ = requestts;
  if (requestts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponseContext.RequestTs)
}

// optional .dg.Time ResponseTs = 5;
inline bool WitnessResponseContext::has_responsets() const {
  return !_is_default_instance_ && responsets_ != NULL;
}
inline void WitnessResponseContext::clear_responsets() {
  if (GetArenaNoVirtual() == NULL && responsets_ != NULL) delete responsets_;
  responsets_ = NULL;
}
inline const ::dg::Time& WitnessResponseContext::responsets() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResponseContext.ResponseTs)
  return responsets_ != NULL ? *responsets_ : *default_instance_->responsets_;
}
inline ::dg::Time* WitnessResponseContext::mutable_responsets() {
  
  if (responsets_ == NULL) {
    responsets_ = new ::dg::Time;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessResponseContext.ResponseTs)
  return responsets_;
}
inline ::dg::Time* WitnessResponseContext::release_responsets() {
  
  ::dg::Time* temp = responsets_;
  responsets_ = NULL;
  return temp;
}
inline void WitnessResponseContext::set_allocated_responsets(::dg::Time* responsets) {
  delete responsets_;
  responsets_ = responsets;
  if (responsets) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResponseContext.ResponseTs)
}

// map<string, .dg.Time> DebugTs = 6;
inline int WitnessResponseContext::debugts_size() const {
  return debugts_.size();
}
inline void WitnessResponseContext::clear_debugts() {
  debugts_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::dg::Time >&
WitnessResponseContext::debugts() const {
  // @@protoc_insertion_point(field_map:dg.WitnessResponseContext.DebugTs)
  return debugts_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::dg::Time >*
WitnessResponseContext::mutable_debugts() {
  // @@protoc_insertion_point(field_mutable_map:dg.WitnessResponseContext.DebugTs)
  return debugts_.MutableMap();
}

// -------------------------------------------------------------------

// WitnessResult

// optional string InnerStatus = 1;
inline void WitnessResult::clear_innerstatus() {
  innerstatus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessResult::innerstatus() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResult.InnerStatus)
  return innerstatus_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResult::set_innerstatus(const ::std::string& value) {
  
  innerstatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessResult.InnerStatus)
}
inline void WitnessResult::set_innerstatus(const char* value) {
  
  innerstatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessResult.InnerStatus)
}
inline void WitnessResult::set_innerstatus(const char* value, size_t size) {
  
  innerstatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessResult.InnerStatus)
}
inline ::std::string* WitnessResult::mutable_innerstatus() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessResult.InnerStatus)
  return innerstatus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessResult::release_innerstatus() {
  
  return innerstatus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResult::set_allocated_innerstatus(::std::string* innerstatus) {
  if (innerstatus != NULL) {
    
  } else {
    
  }
  innerstatus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), innerstatus);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResult.InnerStatus)
}

// optional string InnerMessage = 2;
inline void WitnessResult::clear_innermessage() {
  innermessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WitnessResult::innermessage() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResult.InnerMessage)
  return innermessage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResult::set_innermessage(const ::std::string& value) {
  
  innermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.WitnessResult.InnerMessage)
}
inline void WitnessResult::set_innermessage(const char* value) {
  
  innermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.WitnessResult.InnerMessage)
}
inline void WitnessResult::set_innermessage(const char* value, size_t size) {
  
  innermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.WitnessResult.InnerMessage)
}
inline ::std::string* WitnessResult::mutable_innermessage() {
  
  // @@protoc_insertion_point(field_mutable:dg.WitnessResult.InnerMessage)
  return innermessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WitnessResult::release_innermessage() {
  
  return innermessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WitnessResult::set_allocated_innermessage(::std::string* innermessage) {
  if (innermessage != NULL) {
    
  } else {
    
  }
  innermessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), innermessage);
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResult.InnerMessage)
}

// optional .dg.WitnessImage Image = 3;
inline bool WitnessResult::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
inline void WitnessResult::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::dg::WitnessImage& WitnessResult::image() const {
  // @@protoc_insertion_point(field_get:dg.WitnessResult.Image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::dg::WitnessImage* WitnessResult::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::dg::WitnessImage;
  }
  // @@protoc_insertion_point(field_mutable:dg.WitnessResult.Image)
  return image_;
}
inline ::dg::WitnessImage* WitnessResult::release_image() {
  
  ::dg::WitnessImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void WitnessResult::set_allocated_image(::dg::WitnessImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.WitnessResult.Image)
}

// repeated .dg.RecognizedVehicle Vehicles = 4;
inline int WitnessResult::vehicles_size() const {
  return vehicles_.size();
}
inline void WitnessResult::clear_vehicles() {
  vehicles_.Clear();
}
inline const ::dg::RecognizedVehicle& WitnessResult::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:dg.WitnessResult.Vehicles)
  return vehicles_.Get(index);
}
inline ::dg::RecognizedVehicle* WitnessResult::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:dg.WitnessResult.Vehicles)
  return vehicles_.Mutable(index);
}
inline ::dg::RecognizedVehicle* WitnessResult::add_vehicles() {
  // @@protoc_insertion_point(field_add:dg.WitnessResult.Vehicles)
  return vehicles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::RecognizedVehicle >*
WitnessResult::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:dg.WitnessResult.Vehicles)
  return &vehicles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::RecognizedVehicle >&
WitnessResult::vehicles() const {
  // @@protoc_insertion_point(field_list:dg.WitnessResult.Vehicles)
  return vehicles_;
}

// repeated .dg.RecognizedFace Faces = 5;
inline int WitnessResult::faces_size() const {
  return faces_.size();
}
inline void WitnessResult::clear_faces() {
  faces_.Clear();
}
inline const ::dg::RecognizedFace& WitnessResult::faces(int index) const {
  // @@protoc_insertion_point(field_get:dg.WitnessResult.Faces)
  return faces_.Get(index);
}
inline ::dg::RecognizedFace* WitnessResult::mutable_faces(int index) {
  // @@protoc_insertion_point(field_mutable:dg.WitnessResult.Faces)
  return faces_.Mutable(index);
}
inline ::dg::RecognizedFace* WitnessResult::add_faces() {
  // @@protoc_insertion_point(field_add:dg.WitnessResult.Faces)
  return faces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::RecognizedFace >*
WitnessResult::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:dg.WitnessResult.Faces)
  return &faces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::RecognizedFace >&
WitnessResult::faces() const {
  // @@protoc_insertion_point(field_list:dg.WitnessResult.Faces)
  return faces_;
}

// -------------------------------------------------------------------

// RecognizedVehicle

// optional .dg.VehicleModel Model = 1;
inline bool RecognizedVehicle::has_model() const {
  return !_is_default_instance_ && model_ != NULL;
}
inline void RecognizedVehicle::clear_model() {
  if (GetArenaNoVirtual() == NULL && model_ != NULL) delete model_;
  model_ = NULL;
}
inline const ::dg::VehicleModel& RecognizedVehicle::model() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.Model)
  return model_ != NULL ? *model_ : *default_instance_->model_;
}
inline ::dg::VehicleModel* RecognizedVehicle::mutable_model() {
  
  if (model_ == NULL) {
    model_ = new ::dg::VehicleModel;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.Model)
  return model_;
}
inline ::dg::VehicleModel* RecognizedVehicle::release_model() {
  
  ::dg::VehicleModel* temp = model_;
  model_ = NULL;
  return temp;
}
inline void RecognizedVehicle::set_allocated_model(::dg::VehicleModel* model) {
  delete model_;
  model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedVehicle.Model)
}

// optional .dg.Cutboard Cutboard = 2;
inline bool RecognizedVehicle::has_cutboard() const {
  return !_is_default_instance_ && cutboard_ != NULL;
}
inline void RecognizedVehicle::clear_cutboard() {
  if (GetArenaNoVirtual() == NULL && cutboard_ != NULL) delete cutboard_;
  cutboard_ = NULL;
}
inline const ::dg::Cutboard& RecognizedVehicle::cutboard() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.Cutboard)
  return cutboard_ != NULL ? *cutboard_ : *default_instance_->cutboard_;
}
inline ::dg::Cutboard* RecognizedVehicle::mutable_cutboard() {
  
  if (cutboard_ == NULL) {
    cutboard_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.Cutboard)
  return cutboard_;
}
inline ::dg::Cutboard* RecognizedVehicle::release_cutboard() {
  
  ::dg::Cutboard* temp = cutboard_;
  cutboard_ = NULL;
  return temp;
}
inline void RecognizedVehicle::set_allocated_cutboard(::dg::Cutboard* cutboard) {
  delete cutboard_;
  cutboard_ = cutboard;
  if (cutboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedVehicle.Cutboard)
}

// optional .dg.Color Color = 3;
inline bool RecognizedVehicle::has_color() const {
  return !_is_default_instance_ && color_ != NULL;
}
inline void RecognizedVehicle::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::dg::Color& RecognizedVehicle::color() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.Color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::dg::Color* RecognizedVehicle::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::dg::Color;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.Color)
  return color_;
}
inline ::dg::Color* RecognizedVehicle::release_color() {
  
  ::dg::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void RecognizedVehicle::set_allocated_color(::dg::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedVehicle.Color)
}

// optional .dg.LicensePlate LicensePlate = 4;
inline bool RecognizedVehicle::has_licenseplate() const {
  return !_is_default_instance_ && licenseplate_ != NULL;
}
inline void RecognizedVehicle::clear_licenseplate() {
  if (GetArenaNoVirtual() == NULL && licenseplate_ != NULL) delete licenseplate_;
  licenseplate_ = NULL;
}
inline const ::dg::LicensePlate& RecognizedVehicle::licenseplate() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.LicensePlate)
  return licenseplate_ != NULL ? *licenseplate_ : *default_instance_->licenseplate_;
}
inline ::dg::LicensePlate* RecognizedVehicle::mutable_licenseplate() {
  
  if (licenseplate_ == NULL) {
    licenseplate_ = new ::dg::LicensePlate;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.LicensePlate)
  return licenseplate_;
}
inline ::dg::LicensePlate* RecognizedVehicle::release_licenseplate() {
  
  ::dg::LicensePlate* temp = licenseplate_;
  licenseplate_ = NULL;
  return temp;
}
inline void RecognizedVehicle::set_allocated_licenseplate(::dg::LicensePlate* licenseplate) {
  delete licenseplate_;
  licenseplate_ = licenseplate;
  if (licenseplate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedVehicle.LicensePlate)
}

// repeated .dg.SymbolItem SymbolItems = 5;
inline int RecognizedVehicle::symbolitems_size() const {
  return symbolitems_.size();
}
inline void RecognizedVehicle::clear_symbolitems() {
  symbolitems_.Clear();
}
inline const ::dg::SymbolItem& RecognizedVehicle::symbolitems(int index) const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.SymbolItems)
  return symbolitems_.Get(index);
}
inline ::dg::SymbolItem* RecognizedVehicle::mutable_symbolitems(int index) {
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.SymbolItems)
  return symbolitems_.Mutable(index);
}
inline ::dg::SymbolItem* RecognizedVehicle::add_symbolitems() {
  // @@protoc_insertion_point(field_add:dg.RecognizedVehicle.SymbolItems)
  return symbolitems_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::SymbolItem >*
RecognizedVehicle::mutable_symbolitems() {
  // @@protoc_insertion_point(field_mutable_list:dg.RecognizedVehicle.SymbolItems)
  return &symbolitems_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::SymbolItem >&
RecognizedVehicle::symbolitems() const {
  // @@protoc_insertion_point(field_list:dg.RecognizedVehicle.SymbolItems)
  return symbolitems_;
}

// repeated .dg.VehicleModel Candidates = 6;
inline int RecognizedVehicle::candidates_size() const {
  return candidates_.size();
}
inline void RecognizedVehicle::clear_candidates() {
  candidates_.Clear();
}
inline const ::dg::VehicleModel& RecognizedVehicle::candidates(int index) const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.Candidates)
  return candidates_.Get(index);
}
inline ::dg::VehicleModel* RecognizedVehicle::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.Candidates)
  return candidates_.Mutable(index);
}
inline ::dg::VehicleModel* RecognizedVehicle::add_candidates() {
  // @@protoc_insertion_point(field_add:dg.RecognizedVehicle.Candidates)
  return candidates_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::VehicleModel >*
RecognizedVehicle::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:dg.RecognizedVehicle.Candidates)
  return &candidates_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::VehicleModel >&
RecognizedVehicle::candidates() const {
  // @@protoc_insertion_point(field_list:dg.RecognizedVehicle.Candidates)
  return candidates_;
}

// optional string Features = 7;
inline void RecognizedVehicle::clear_features() {
  features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognizedVehicle::features() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.Features)
  return features_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizedVehicle::set_features(const ::std::string& value) {
  
  features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.RecognizedVehicle.Features)
}
inline void RecognizedVehicle::set_features(const char* value) {
  
  features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.RecognizedVehicle.Features)
}
inline void RecognizedVehicle::set_features(const char* value, size_t size) {
  
  features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.RecognizedVehicle.Features)
}
inline ::std::string* RecognizedVehicle::mutable_features() {
  
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.Features)
  return features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognizedVehicle::release_features() {
  
  return features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizedVehicle::set_allocated_features(::std::string* features) {
  if (features != NULL) {
    
  } else {
    
  }
  features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), features);
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedVehicle.Features)
}

// optional .dg.Scene Scene = 8;
inline bool RecognizedVehicle::has_scene() const {
  return !_is_default_instance_ && scene_ != NULL;
}
inline void RecognizedVehicle::clear_scene() {
  if (GetArenaNoVirtual() == NULL && scene_ != NULL) delete scene_;
  scene_ = NULL;
}
inline const ::dg::Scene& RecognizedVehicle::scene() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedVehicle.Scene)
  return scene_ != NULL ? *scene_ : *default_instance_->scene_;
}
inline ::dg::Scene* RecognizedVehicle::mutable_scene() {
  
  if (scene_ == NULL) {
    scene_ = new ::dg::Scene;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizedVehicle.Scene)
  return scene_;
}
inline ::dg::Scene* RecognizedVehicle::release_scene() {
  
  ::dg::Scene* temp = scene_;
  scene_ = NULL;
  return temp;
}
inline void RecognizedVehicle::set_allocated_scene(::dg::Scene* scene) {
  delete scene_;
  scene_ = scene;
  if (scene) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedVehicle.Scene)
}

// -------------------------------------------------------------------

// RecognizedFace

// optional .dg.Cutboard Cutboard = 1;
inline bool RecognizedFace::has_cutboard() const {
  return !_is_default_instance_ && cutboard_ != NULL;
}
inline void RecognizedFace::clear_cutboard() {
  if (GetArenaNoVirtual() == NULL && cutboard_ != NULL) delete cutboard_;
  cutboard_ = NULL;
}
inline const ::dg::Cutboard& RecognizedFace::cutboard() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedFace.Cutboard)
  return cutboard_ != NULL ? *cutboard_ : *default_instance_->cutboard_;
}
inline ::dg::Cutboard* RecognizedFace::mutable_cutboard() {
  
  if (cutboard_ == NULL) {
    cutboard_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizedFace.Cutboard)
  return cutboard_;
}
inline ::dg::Cutboard* RecognizedFace::release_cutboard() {
  
  ::dg::Cutboard* temp = cutboard_;
  cutboard_ = NULL;
  return temp;
}
inline void RecognizedFace::set_allocated_cutboard(::dg::Cutboard* cutboard) {
  delete cutboard_;
  cutboard_ = cutboard;
  if (cutboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedFace.Cutboard)
}

// optional float Confidence = 2;
inline void RecognizedFace::clear_confidence() {
  confidence_ = 0;
}
inline float RecognizedFace::confidence() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedFace.Confidence)
  return confidence_;
}
inline void RecognizedFace::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizedFace.Confidence)
}

// optional string Features = 3;
inline void RecognizedFace::clear_features() {
  features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognizedFace::features() const {
  // @@protoc_insertion_point(field_get:dg.RecognizedFace.Features)
  return features_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizedFace::set_features(const ::std::string& value) {
  
  features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.RecognizedFace.Features)
}
inline void RecognizedFace::set_features(const char* value) {
  
  features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.RecognizedFace.Features)
}
inline void RecognizedFace::set_features(const char* value, size_t size) {
  
  features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.RecognizedFace.Features)
}
inline ::std::string* RecognizedFace::mutable_features() {
  
  // @@protoc_insertion_point(field_mutable:dg.RecognizedFace.Features)
  return features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognizedFace::release_features() {
  
  return features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizedFace::set_allocated_features(::std::string* features) {
  if (features != NULL) {
    
  } else {
    
  }
  features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), features);
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizedFace.Features)
}

// -------------------------------------------------------------------

// VehicleModel

// optional int32 TypeId = 1;
inline void VehicleModel::clear_typeid_() {
  typeid__ = 0;
}
inline ::google::protobuf::int32 VehicleModel::typeid_() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.TypeId)
  return typeid__;
}
inline void VehicleModel::set_typeid_(::google::protobuf::int32 value) {
  
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleModel.TypeId)
}

// optional int32 BrandId = 2;
inline void VehicleModel::clear_brandid() {
  brandid_ = 0;
}
inline ::google::protobuf::int32 VehicleModel::brandid() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.BrandId)
  return brandid_;
}
inline void VehicleModel::set_brandid(::google::protobuf::int32 value) {
  
  brandid_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleModel.BrandId)
}

// optional int32 SubBrandId = 3;
inline void VehicleModel::clear_subbrandid() {
  subbrandid_ = 0;
}
inline ::google::protobuf::int32 VehicleModel::subbrandid() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.SubBrandId)
  return subbrandid_;
}
inline void VehicleModel::set_subbrandid(::google::protobuf::int32 value) {
  
  subbrandid_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleModel.SubBrandId)
}

// optional int32 ModelYearId = 4;
inline void VehicleModel::clear_modelyearid() {
  modelyearid_ = 0;
}
inline ::google::protobuf::int32 VehicleModel::modelyearid() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.ModelYearId)
  return modelyearid_;
}
inline void VehicleModel::set_modelyearid(::google::protobuf::int32 value) {
  
  modelyearid_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleModel.ModelYearId)
}

// optional string Type = 5;
inline void VehicleModel::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VehicleModel::type() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.Type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.VehicleModel.Type)
}
inline void VehicleModel::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.VehicleModel.Type)
}
inline void VehicleModel::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.VehicleModel.Type)
}
inline ::std::string* VehicleModel::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:dg.VehicleModel.Type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleModel::release_type() {
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:dg.VehicleModel.Type)
}

// optional string Brand = 6;
inline void VehicleModel::clear_brand() {
  brand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VehicleModel::brand() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.Brand)
  return brand_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_brand(const ::std::string& value) {
  
  brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.VehicleModel.Brand)
}
inline void VehicleModel::set_brand(const char* value) {
  
  brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.VehicleModel.Brand)
}
inline void VehicleModel::set_brand(const char* value, size_t size) {
  
  brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.VehicleModel.Brand)
}
inline ::std::string* VehicleModel::mutable_brand() {
  
  // @@protoc_insertion_point(field_mutable:dg.VehicleModel.Brand)
  return brand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleModel::release_brand() {
  
  return brand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_allocated_brand(::std::string* brand) {
  if (brand != NULL) {
    
  } else {
    
  }
  brand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brand);
  // @@protoc_insertion_point(field_set_allocated:dg.VehicleModel.Brand)
}

// optional string SubBrand = 7;
inline void VehicleModel::clear_subbrand() {
  subbrand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VehicleModel::subbrand() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.SubBrand)
  return subbrand_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_subbrand(const ::std::string& value) {
  
  subbrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.VehicleModel.SubBrand)
}
inline void VehicleModel::set_subbrand(const char* value) {
  
  subbrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.VehicleModel.SubBrand)
}
inline void VehicleModel::set_subbrand(const char* value, size_t size) {
  
  subbrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.VehicleModel.SubBrand)
}
inline ::std::string* VehicleModel::mutable_subbrand() {
  
  // @@protoc_insertion_point(field_mutable:dg.VehicleModel.SubBrand)
  return subbrand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleModel::release_subbrand() {
  
  return subbrand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_allocated_subbrand(::std::string* subbrand) {
  if (subbrand != NULL) {
    
  } else {
    
  }
  subbrand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subbrand);
  // @@protoc_insertion_point(field_set_allocated:dg.VehicleModel.SubBrand)
}

// optional string ModelYear = 8;
inline void VehicleModel::clear_modelyear() {
  modelyear_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VehicleModel::modelyear() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.ModelYear)
  return modelyear_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_modelyear(const ::std::string& value) {
  
  modelyear_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.VehicleModel.ModelYear)
}
inline void VehicleModel::set_modelyear(const char* value) {
  
  modelyear_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.VehicleModel.ModelYear)
}
inline void VehicleModel::set_modelyear(const char* value, size_t size) {
  
  modelyear_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.VehicleModel.ModelYear)
}
inline ::std::string* VehicleModel::mutable_modelyear() {
  
  // @@protoc_insertion_point(field_mutable:dg.VehicleModel.ModelYear)
  return modelyear_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleModel::release_modelyear() {
  
  return modelyear_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleModel::set_allocated_modelyear(::std::string* modelyear) {
  if (modelyear != NULL) {
    
  } else {
    
  }
  modelyear_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelyear);
  // @@protoc_insertion_point(field_set_allocated:dg.VehicleModel.ModelYear)
}

// optional int32 IsHead = 9;
inline void VehicleModel::clear_ishead() {
  ishead_ = 0;
}
inline ::google::protobuf::int32 VehicleModel::ishead() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.IsHead)
  return ishead_;
}
inline void VehicleModel::set_ishead(::google::protobuf::int32 value) {
  
  ishead_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleModel.IsHead)
}

// optional float Confidence = 10;
inline void VehicleModel::clear_confidence() {
  confidence_ = 0;
}
inline float VehicleModel::confidence() const {
  // @@protoc_insertion_point(field_get:dg.VehicleModel.Confidence)
  return confidence_;
}
inline void VehicleModel::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleModel.Confidence)
}

// -------------------------------------------------------------------

// LicensePlate

// optional string PlateNum = 1;
inline void LicensePlate::clear_platenum() {
  platenum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LicensePlate::platenum() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.PlateNum)
  return platenum_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LicensePlate::set_platenum(const ::std::string& value) {
  
  platenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.LicensePlate.PlateNum)
}
inline void LicensePlate::set_platenum(const char* value) {
  
  platenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.LicensePlate.PlateNum)
}
inline void LicensePlate::set_platenum(const char* value, size_t size) {
  
  platenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.LicensePlate.PlateNum)
}
inline ::std::string* LicensePlate::mutable_platenum() {
  
  // @@protoc_insertion_point(field_mutable:dg.LicensePlate.PlateNum)
  return platenum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LicensePlate::release_platenum() {
  
  return platenum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LicensePlate::set_allocated_platenum(::std::string* platenum) {
  if (platenum != NULL) {
    
  } else {
    
  }
  platenum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platenum);
  // @@protoc_insertion_point(field_set_allocated:dg.LicensePlate.PlateNum)
}

// optional .dg.Cutboard Cutboard = 2;
inline bool LicensePlate::has_cutboard() const {
  return !_is_default_instance_ && cutboard_ != NULL;
}
inline void LicensePlate::clear_cutboard() {
  if (GetArenaNoVirtual() == NULL && cutboard_ != NULL) delete cutboard_;
  cutboard_ = NULL;
}
inline const ::dg::Cutboard& LicensePlate::cutboard() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.Cutboard)
  return cutboard_ != NULL ? *cutboard_ : *default_instance_->cutboard_;
}
inline ::dg::Cutboard* LicensePlate::mutable_cutboard() {
  
  if (cutboard_ == NULL) {
    cutboard_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.LicensePlate.Cutboard)
  return cutboard_;
}
inline ::dg::Cutboard* LicensePlate::release_cutboard() {
  
  ::dg::Cutboard* temp = cutboard_;
  cutboard_ = NULL;
  return temp;
}
inline void LicensePlate::set_allocated_cutboard(::dg::Cutboard* cutboard) {
  delete cutboard_;
  cutboard_ = cutboard;
  if (cutboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.LicensePlate.Cutboard)
}

// optional int32 ColorId = 3;
inline void LicensePlate::clear_colorid() {
  colorid_ = 0;
}
inline ::google::protobuf::int32 LicensePlate::colorid() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.ColorId)
  return colorid_;
}
inline void LicensePlate::set_colorid(::google::protobuf::int32 value) {
  
  colorid_ = value;
  // @@protoc_insertion_point(field_set:dg.LicensePlate.ColorId)
}

// optional string Color = 4;
inline void LicensePlate::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LicensePlate::color() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.Color)
  return color_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LicensePlate::set_color(const ::std::string& value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.LicensePlate.Color)
}
inline void LicensePlate::set_color(const char* value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.LicensePlate.Color)
}
inline void LicensePlate::set_color(const char* value, size_t size) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.LicensePlate.Color)
}
inline ::std::string* LicensePlate::mutable_color() {
  
  // @@protoc_insertion_point(field_mutable:dg.LicensePlate.Color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LicensePlate::release_color() {
  
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LicensePlate::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    
  } else {
    
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:dg.LicensePlate.Color)
}

// optional int32 TypeId = 5;
inline void LicensePlate::clear_typeid_() {
  typeid__ = 0;
}
inline ::google::protobuf::int32 LicensePlate::typeid_() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.TypeId)
  return typeid__;
}
inline void LicensePlate::set_typeid_(::google::protobuf::int32 value) {
  
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dg.LicensePlate.TypeId)
}

// optional string Type = 6;
inline void LicensePlate::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LicensePlate::type() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.Type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LicensePlate::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.LicensePlate.Type)
}
inline void LicensePlate::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.LicensePlate.Type)
}
inline void LicensePlate::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.LicensePlate.Type)
}
inline ::std::string* LicensePlate::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:dg.LicensePlate.Type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LicensePlate::release_type() {
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LicensePlate::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:dg.LicensePlate.Type)
}

// optional float Confidence = 7;
inline void LicensePlate::clear_confidence() {
  confidence_ = 0;
}
inline float LicensePlate::confidence() const {
  // @@protoc_insertion_point(field_get:dg.LicensePlate.Confidence)
  return confidence_;
}
inline void LicensePlate::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.LicensePlate.Confidence)
}

// -------------------------------------------------------------------

// SymbolItem

// optional int32 SymbolId = 1;
inline void SymbolItem::clear_symbolid() {
  symbolid_ = 0;
}
inline ::google::protobuf::int32 SymbolItem::symbolid() const {
  // @@protoc_insertion_point(field_get:dg.SymbolItem.SymbolId)
  return symbolid_;
}
inline void SymbolItem::set_symbolid(::google::protobuf::int32 value) {
  
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:dg.SymbolItem.SymbolId)
}

// optional string SymbolName = 2;
inline void SymbolItem::clear_symbolname() {
  symbolname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SymbolItem::symbolname() const {
  // @@protoc_insertion_point(field_get:dg.SymbolItem.SymbolName)
  return symbolname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolItem::set_symbolname(const ::std::string& value) {
  
  symbolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.SymbolItem.SymbolName)
}
inline void SymbolItem::set_symbolname(const char* value) {
  
  symbolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.SymbolItem.SymbolName)
}
inline void SymbolItem::set_symbolname(const char* value, size_t size) {
  
  symbolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.SymbolItem.SymbolName)
}
inline ::std::string* SymbolItem::mutable_symbolname() {
  
  // @@protoc_insertion_point(field_mutable:dg.SymbolItem.SymbolName)
  return symbolname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolItem::release_symbolname() {
  
  return symbolname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolItem::set_allocated_symbolname(::std::string* symbolname) {
  if (symbolname != NULL) {
    
  } else {
    
  }
  symbolname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbolname);
  // @@protoc_insertion_point(field_set_allocated:dg.SymbolItem.SymbolName)
}

// repeated .dg.Symbol Symbols = 3;
inline int SymbolItem::symbols_size() const {
  return symbols_.size();
}
inline void SymbolItem::clear_symbols() {
  symbols_.Clear();
}
inline const ::dg::Symbol& SymbolItem::symbols(int index) const {
  // @@protoc_insertion_point(field_get:dg.SymbolItem.Symbols)
  return symbols_.Get(index);
}
inline ::dg::Symbol* SymbolItem::mutable_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:dg.SymbolItem.Symbols)
  return symbols_.Mutable(index);
}
inline ::dg::Symbol* SymbolItem::add_symbols() {
  // @@protoc_insertion_point(field_add:dg.SymbolItem.Symbols)
  return symbols_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::Symbol >*
SymbolItem::mutable_symbols() {
  // @@protoc_insertion_point(field_mutable_list:dg.SymbolItem.Symbols)
  return &symbols_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::Symbol >&
SymbolItem::symbols() const {
  // @@protoc_insertion_point(field_list:dg.SymbolItem.Symbols)
  return symbols_;
}

// -------------------------------------------------------------------

// Scene

// optional int32 IsHead = 1;
inline void Scene::clear_ishead() {
  ishead_ = 0;
}
inline ::google::protobuf::int32 Scene::ishead() const {
  // @@protoc_insertion_point(field_get:dg.Scene.IsHead)
  return ishead_;
}
inline void Scene::set_ishead(::google::protobuf::int32 value) {
  
  ishead_ = value;
  // @@protoc_insertion_point(field_set:dg.Scene.IsHead)
}

// optional int32 IsDay = 2;
inline void Scene::clear_isday() {
  isday_ = 0;
}
inline ::google::protobuf::int32 Scene::isday() const {
  // @@protoc_insertion_point(field_get:dg.Scene.IsDay)
  return isday_;
}
inline void Scene::set_isday(::google::protobuf::int32 value) {
  
  isday_ = value;
  // @@protoc_insertion_point(field_set:dg.Scene.IsDay)
}

// optional string Border = 3;
inline void Scene::clear_border() {
  border_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scene::border() const {
  // @@protoc_insertion_point(field_get:dg.Scene.Border)
  return border_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scene::set_border(const ::std::string& value) {
  
  border_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.Scene.Border)
}
inline void Scene::set_border(const char* value) {
  
  border_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.Scene.Border)
}
inline void Scene::set_border(const char* value, size_t size) {
  
  border_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.Scene.Border)
}
inline ::std::string* Scene::mutable_border() {
  
  // @@protoc_insertion_point(field_mutable:dg.Scene.Border)
  return border_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scene::release_border() {
  
  return border_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scene::set_allocated_border(::std::string* border) {
  if (border != NULL) {
    
  } else {
    
  }
  border_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), border);
  // @@protoc_insertion_point(field_set_allocated:dg.Scene.Border)
}

// -------------------------------------------------------------------

// Symbol

// optional .dg.Cutboard Cutboard = 3;
inline bool Symbol::has_cutboard() const {
  return !_is_default_instance_ && cutboard_ != NULL;
}
inline void Symbol::clear_cutboard() {
  if (GetArenaNoVirtual() == NULL && cutboard_ != NULL) delete cutboard_;
  cutboard_ = NULL;
}
inline const ::dg::Cutboard& Symbol::cutboard() const {
  // @@protoc_insertion_point(field_get:dg.Symbol.Cutboard)
  return cutboard_ != NULL ? *cutboard_ : *default_instance_->cutboard_;
}
inline ::dg::Cutboard* Symbol::mutable_cutboard() {
  
  if (cutboard_ == NULL) {
    cutboard_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.Symbol.Cutboard)
  return cutboard_;
}
inline ::dg::Cutboard* Symbol::release_cutboard() {
  
  ::dg::Cutboard* temp = cutboard_;
  cutboard_ = NULL;
  return temp;
}
inline void Symbol::set_allocated_cutboard(::dg::Cutboard* cutboard) {
  delete cutboard_;
  cutboard_ = cutboard;
  if (cutboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.Symbol.Cutboard)
}

// optional float Confidence = 4;
inline void Symbol::clear_confidence() {
  confidence_ = 0;
}
inline float Symbol::confidence() const {
  // @@protoc_insertion_point(field_get:dg.Symbol.Confidence)
  return confidence_;
}
inline void Symbol::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.Symbol.Confidence)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dg::WitnessFunction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dg::WitnessFunction>() {
  return ::dg::WitnessFunction_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_witness_2eproto__INCLUDED
