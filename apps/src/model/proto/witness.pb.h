// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: witness.proto

#ifndef PROTOBUF_witness_2eproto__INCLUDED
#define PROTOBUF_witness_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace dg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_witness_2eproto();
void protobuf_AssignDesc_witness_2eproto();
void protobuf_ShutdownFile_witness_2eproto();

class BatchRecognizeRequest;
class BatchRecognizeResponse;
class Feature;
class RecognizeParam;
class RecognizeRequest;
class RecognizeResponse;
class RecognizeResult;
class RecognizeStatus;
class VehicleBrand;
class VehiclePlate;
class VehicleSymbol;

enum RecognizeType {
  REC_TYPE_DEFAULT = 0,
  REC_TYPE_VEHICLE = 1,
  REC_TYPE_FACE = 2,
  RecognizeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RecognizeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RecognizeType_IsValid(int value);
const RecognizeType RecognizeType_MIN = REC_TYPE_DEFAULT;
const RecognizeType RecognizeType_MAX = REC_TYPE_FACE;
const int RecognizeType_ARRAYSIZE = RecognizeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecognizeType_descriptor();
inline const ::std::string& RecognizeType_Name(RecognizeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecognizeType_descriptor(), value);
}
inline bool RecognizeType_Parse(
    const ::std::string& name, RecognizeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecognizeType>(
    RecognizeType_descriptor(), name, value);
}
enum RecognizeFunction {
  REC_FUNC_DEFAULT = 0,
  REC_FUNC_DETECTION = 1,
  REC_FUNC_FEATURE = 2,
  RecognizeFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RecognizeFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RecognizeFunction_IsValid(int value);
const RecognizeFunction RecognizeFunction_MIN = REC_FUNC_DEFAULT;
const RecognizeFunction RecognizeFunction_MAX = REC_FUNC_FEATURE;
const int RecognizeFunction_ARRAYSIZE = RecognizeFunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecognizeFunction_descriptor();
inline const ::std::string& RecognizeFunction_Name(RecognizeFunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecognizeFunction_descriptor(), value);
}
inline bool RecognizeFunction_Parse(
    const ::std::string& name, RecognizeFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecognizeFunction>(
    RecognizeFunction_descriptor(), name, value);
}
// ===================================================================

class RecognizeStatus : public ::google::protobuf::Message {
 public:
  RecognizeStatus();
  virtual ~RecognizeStatus();

  RecognizeStatus(const RecognizeStatus& from);

  inline RecognizeStatus& operator=(const RecognizeStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeStatus& default_instance();

  void Swap(RecognizeStatus* other);

  // implements Message ----------------------------------------------

  inline RecognizeStatus* New() const { return New(NULL); }

  RecognizeStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeStatus& from);
  void MergeFrom(const RecognizeStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // optional string Msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:dg.RecognizeStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizeStatus* default_instance_;
};
// -------------------------------------------------------------------

class RecognizeParam : public ::google::protobuf::Message {
 public:
  RecognizeParam();
  virtual ~RecognizeParam();

  RecognizeParam(const RecognizeParam& from);

  inline RecognizeParam& operator=(const RecognizeParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeParam& default_instance();

  void Swap(RecognizeParam* other);

  // implements Message ----------------------------------------------

  inline RecognizeParam* New() const { return New(NULL); }

  RecognizeParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeParam& from);
  void MergeFrom(const RecognizeParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.RecognizeType Type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::dg::RecognizeType type() const;
  void set_type(::dg::RecognizeType value);

  // optional .dg.RecognizeFunction Function = 2;
  void clear_function();
  static const int kFunctionFieldNumber = 2;
  ::dg::RecognizeFunction function() const;
  void set_function(::dg::RecognizeFunction value);

  // @@protoc_insertion_point(class_scope:dg.RecognizeParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  int function_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizeParam* default_instance_;
};
// -------------------------------------------------------------------

class RecognizeRequest : public ::google::protobuf::Message {
 public:
  RecognizeRequest();
  virtual ~RecognizeRequest();

  RecognizeRequest(const RecognizeRequest& from);

  inline RecognizeRequest& operator=(const RecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeRequest& default_instance();

  void Swap(RecognizeRequest* other);

  // implements Message ----------------------------------------------

  inline RecognizeRequest* New() const { return New(NULL); }

  RecognizeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeRequest& from);
  void MergeFrom(const RecognizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 SessionId = 1;
  void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  ::google::protobuf::int64 sessionid() const;
  void set_sessionid(::google::protobuf::int64 value);

  // optional .dg.Image Image = 2;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::dg::Image& image() const;
  ::dg::Image* mutable_image();
  ::dg::Image* release_image();
  void set_allocated_image(::dg::Image* image);

  // optional .dg.RecognizeParam Param = 3;
  bool has_param() const;
  void clear_param();
  static const int kParamFieldNumber = 3;
  const ::dg::RecognizeParam& param() const;
  ::dg::RecognizeParam* mutable_param();
  ::dg::RecognizeParam* release_param();
  void set_allocated_param(::dg::RecognizeParam* param);

  // @@protoc_insertion_point(class_scope:dg.RecognizeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 sessionid_;
  ::dg::Image* image_;
  ::dg::RecognizeParam* param_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class VehicleBrand : public ::google::protobuf::Message {
 public:
  VehicleBrand();
  virtual ~VehicleBrand();

  VehicleBrand(const VehicleBrand& from);

  inline VehicleBrand& operator=(const VehicleBrand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleBrand& default_instance();

  void Swap(VehicleBrand* other);

  // implements Message ----------------------------------------------

  inline VehicleBrand* New() const { return New(NULL); }

  VehicleBrand* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleBrand& from);
  void MergeFrom(const VehicleBrand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleBrand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 BrandId = 1;
  void clear_brandid();
  static const int kBrandIdFieldNumber = 1;
  ::google::protobuf::int32 brandid() const;
  void set_brandid(::google::protobuf::int32 value);

  // optional float Confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:dg.VehicleBrand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 brandid_;
  float confidence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static VehicleBrand* default_instance_;
};
// -------------------------------------------------------------------

class VehiclePlate : public ::google::protobuf::Message {
 public:
  VehiclePlate();
  virtual ~VehiclePlate();

  VehiclePlate(const VehiclePlate& from);

  inline VehiclePlate& operator=(const VehiclePlate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePlate& default_instance();

  void Swap(VehiclePlate* other);

  // implements Message ----------------------------------------------

  inline VehiclePlate* New() const { return New(NULL); }

  VehiclePlate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehiclePlate& from);
  void MergeFrom(const VehiclePlate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehiclePlate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.Cutboard Box = 1;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 1;
  const ::dg::Cutboard& box() const;
  ::dg::Cutboard* mutable_box();
  ::dg::Cutboard* release_box();
  void set_allocated_box(::dg::Cutboard* box);

  // optional int32 PlateType = 2;
  void clear_platetype();
  static const int kPlateTypeFieldNumber = 2;
  ::google::protobuf::int32 platetype() const;
  void set_platetype(::google::protobuf::int32 value);

  // optional string PlateNum = 3;
  void clear_platenum();
  static const int kPlateNumFieldNumber = 3;
  const ::std::string& platenum() const;
  void set_platenum(const ::std::string& value);
  void set_platenum(const char* value);
  void set_platenum(const char* value, size_t size);
  ::std::string* mutable_platenum();
  ::std::string* release_platenum();
  void set_allocated_platenum(::std::string* platenum);

  // optional .dg.Color PlateColor = 4;
  bool has_platecolor() const;
  void clear_platecolor();
  static const int kPlateColorFieldNumber = 4;
  const ::dg::Color& platecolor() const;
  ::dg::Color* mutable_platecolor();
  ::dg::Color* release_platecolor();
  void set_allocated_platecolor(::dg::Color* platecolor);

  // optional float Confidence = 5;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 5;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:dg.VehiclePlate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::Cutboard* box_;
  ::google::protobuf::internal::ArenaStringPtr platenum_;
  ::google::protobuf::int32 platetype_;
  float confidence_;
  ::dg::Color* platecolor_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static VehiclePlate* default_instance_;
};
// -------------------------------------------------------------------

class VehicleSymbol : public ::google::protobuf::Message {
 public:
  VehicleSymbol();
  virtual ~VehicleSymbol();

  VehicleSymbol(const VehicleSymbol& from);

  inline VehicleSymbol& operator=(const VehicleSymbol& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleSymbol& default_instance();

  void Swap(VehicleSymbol* other);

  // implements Message ----------------------------------------------

  inline VehicleSymbol* New() const { return New(NULL); }

  VehicleSymbol* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleSymbol& from);
  void MergeFrom(const VehicleSymbol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleSymbol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.Cutboard Box = 1;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 1;
  const ::dg::Cutboard& box() const;
  ::dg::Cutboard* mutable_box();
  ::dg::Cutboard* release_box();
  void set_allocated_box(::dg::Cutboard* box);

  // optional int32 SymbolType = 2;
  void clear_symboltype();
  static const int kSymbolTypeFieldNumber = 2;
  ::google::protobuf::int32 symboltype() const;
  void set_symboltype(::google::protobuf::int32 value);

  // optional float Confidence = 3;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:dg.VehicleSymbol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::Cutboard* box_;
  ::google::protobuf::int32 symboltype_;
  float confidence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static VehicleSymbol* default_instance_;
};
// -------------------------------------------------------------------

class Feature : public ::google::protobuf::Message {
 public:
  Feature();
  virtual ~Feature();

  Feature(const Feature& from);

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Feature& default_instance();

  void Swap(Feature* other);

  // implements Message ----------------------------------------------

  inline Feature* New() const { return New(NULL); }

  Feature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Feature& from);
  void MergeFrom(const Feature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes FeatureVector = 1;
  void clear_featurevector();
  static const int kFeatureVectorFieldNumber = 1;
  const ::std::string& featurevector() const;
  void set_featurevector(const ::std::string& value);
  void set_featurevector(const char* value);
  void set_featurevector(const void* value, size_t size);
  ::std::string* mutable_featurevector();
  ::std::string* release_featurevector();
  void set_allocated_featurevector(::std::string* featurevector);

  // @@protoc_insertion_point(class_scope:dg.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr featurevector_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static Feature* default_instance_;
};
// -------------------------------------------------------------------

class RecognizeResult : public ::google::protobuf::Message {
 public:
  RecognizeResult();
  virtual ~RecognizeResult();

  RecognizeResult(const RecognizeResult& from);

  inline RecognizeResult& operator=(const RecognizeResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeResult& default_instance();

  void Swap(RecognizeResult* other);

  // implements Message ----------------------------------------------

  inline RecognizeResult* New() const { return New(NULL); }

  RecognizeResult* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeResult& from);
  void MergeFrom(const RecognizeResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dg.ObjType Type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::dg::ObjType type() const;
  void set_type(::dg::ObjType value);

  // optional .dg.Cutboard Box = 2;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 2;
  const ::dg::Cutboard& box() const;
  ::dg::Cutboard* mutable_box();
  ::dg::Cutboard* release_box();
  void set_allocated_box(::dg::Cutboard* box);

  // optional .dg.VehicleBrand Brand = 3;
  bool has_brand() const;
  void clear_brand();
  static const int kBrandFieldNumber = 3;
  const ::dg::VehicleBrand& brand() const;
  ::dg::VehicleBrand* mutable_brand();
  ::dg::VehicleBrand* release_brand();
  void set_allocated_brand(::dg::VehicleBrand* brand);

  // optional .dg.VehiclePlate Plate = 4;
  bool has_plate() const;
  void clear_plate();
  static const int kPlateFieldNumber = 4;
  const ::dg::VehiclePlate& plate() const;
  ::dg::VehiclePlate* mutable_plate();
  ::dg::VehiclePlate* release_plate();
  void set_allocated_plate(::dg::VehiclePlate* plate);

  // optional .dg.Color Color = 5;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 5;
  const ::dg::Color& color() const;
  ::dg::Color* mutable_color();
  ::dg::Color* release_color();
  void set_allocated_color(::dg::Color* color);

  // optional .dg.Feature Feature = 6;
  bool has_feature() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 6;
  const ::dg::Feature& feature() const;
  ::dg::Feature* mutable_feature();
  ::dg::Feature* release_feature();
  void set_allocated_feature(::dg::Feature* feature);

  // repeated .dg.VehicleSymbol Symbols = 7;
  int symbols_size() const;
  void clear_symbols();
  static const int kSymbolsFieldNumber = 7;
  const ::dg::VehicleSymbol& symbols(int index) const;
  ::dg::VehicleSymbol* mutable_symbols(int index);
  ::dg::VehicleSymbol* add_symbols();
  ::google::protobuf::RepeatedPtrField< ::dg::VehicleSymbol >*
      mutable_symbols();
  const ::google::protobuf::RepeatedPtrField< ::dg::VehicleSymbol >&
      symbols() const;

  // @@protoc_insertion_point(class_scope:dg.RecognizeResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::dg::Cutboard* box_;
  ::dg::VehicleBrand* brand_;
  ::dg::VehiclePlate* plate_;
  ::dg::Color* color_;
  ::dg::Feature* feature_;
  ::google::protobuf::RepeatedPtrField< ::dg::VehicleSymbol > symbols_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizeResult* default_instance_;
};
// -------------------------------------------------------------------

class RecognizeResponse : public ::google::protobuf::Message {
 public:
  RecognizeResponse();
  virtual ~RecognizeResponse();

  RecognizeResponse(const RecognizeResponse& from);

  inline RecognizeResponse& operator=(const RecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeResponse& default_instance();

  void Swap(RecognizeResponse* other);

  // implements Message ----------------------------------------------

  inline RecognizeResponse* New() const { return New(NULL); }

  RecognizeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeResponse& from);
  void MergeFrom(const RecognizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 SessionId = 1;
  void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  ::google::protobuf::int64 sessionid() const;
  void set_sessionid(::google::protobuf::int64 value);

  // optional .dg.RecognizeStatus Status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::dg::RecognizeStatus& status() const;
  ::dg::RecognizeStatus* mutable_status();
  ::dg::RecognizeStatus* release_status();
  void set_allocated_status(::dg::RecognizeStatus* status);

  // optional .dg.RecognizeResult Result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  const ::dg::RecognizeResult& result() const;
  ::dg::RecognizeResult* mutable_result();
  ::dg::RecognizeResult* release_result();
  void set_allocated_result(::dg::RecognizeResult* result);

  // @@protoc_insertion_point(class_scope:dg.RecognizeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 sessionid_;
  ::dg::RecognizeStatus* status_;
  ::dg::RecognizeResult* result_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static RecognizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class BatchRecognizeRequest : public ::google::protobuf::Message {
 public:
  BatchRecognizeRequest();
  virtual ~BatchRecognizeRequest();

  BatchRecognizeRequest(const BatchRecognizeRequest& from);

  inline BatchRecognizeRequest& operator=(const BatchRecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchRecognizeRequest& default_instance();

  void Swap(BatchRecognizeRequest* other);

  // implements Message ----------------------------------------------

  inline BatchRecognizeRequest* New() const { return New(NULL); }

  BatchRecognizeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchRecognizeRequest& from);
  void MergeFrom(const BatchRecognizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchRecognizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dg.RecognizeRequest Requests = 1;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 1;
  const ::dg::RecognizeRequest& requests(int index) const;
  ::dg::RecognizeRequest* mutable_requests(int index);
  ::dg::RecognizeRequest* add_requests();
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizeRequest >*
      mutable_requests();
  const ::google::protobuf::RepeatedPtrField< ::dg::RecognizeRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:dg.BatchRecognizeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizeRequest > requests_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static BatchRecognizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class BatchRecognizeResponse : public ::google::protobuf::Message {
 public:
  BatchRecognizeResponse();
  virtual ~BatchRecognizeResponse();

  BatchRecognizeResponse(const BatchRecognizeResponse& from);

  inline BatchRecognizeResponse& operator=(const BatchRecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchRecognizeResponse& default_instance();

  void Swap(BatchRecognizeResponse* other);

  // implements Message ----------------------------------------------

  inline BatchRecognizeResponse* New() const { return New(NULL); }

  BatchRecognizeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchRecognizeResponse& from);
  void MergeFrom(const BatchRecognizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchRecognizeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dg.RecognizeResponse Reponses = 1;
  int reponses_size() const;
  void clear_reponses();
  static const int kReponsesFieldNumber = 1;
  const ::dg::RecognizeResponse& reponses(int index) const;
  ::dg::RecognizeResponse* mutable_reponses(int index);
  ::dg::RecognizeResponse* add_reponses();
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizeResponse >*
      mutable_reponses();
  const ::google::protobuf::RepeatedPtrField< ::dg::RecognizeResponse >&
      reponses() const;

  // @@protoc_insertion_point(class_scope:dg.BatchRecognizeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::dg::RecognizeResponse > reponses_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_witness_2eproto();
  friend void protobuf_AssignDesc_witness_2eproto();
  friend void protobuf_ShutdownFile_witness_2eproto();

  void InitAsDefaultInstance();
  static BatchRecognizeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RecognizeStatus

// optional int32 Code = 1;
inline void RecognizeStatus::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 RecognizeStatus::code() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeStatus.Code)
  return code_;
}
inline void RecognizeStatus::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizeStatus.Code)
}

// optional string Msg = 2;
inline void RecognizeStatus::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognizeStatus::msg() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeStatus.Msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeStatus::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.RecognizeStatus.Msg)
}
inline void RecognizeStatus::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.RecognizeStatus.Msg)
}
inline void RecognizeStatus::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.RecognizeStatus.Msg)
}
inline ::std::string* RecognizeStatus::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:dg.RecognizeStatus.Msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognizeStatus::release_msg() {
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeStatus::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeStatus.Msg)
}

// -------------------------------------------------------------------

// RecognizeParam

// optional .dg.RecognizeType Type = 1;
inline void RecognizeParam::clear_type() {
  type_ = 0;
}
inline ::dg::RecognizeType RecognizeParam::type() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeParam.Type)
  return static_cast< ::dg::RecognizeType >(type_);
}
inline void RecognizeParam::set_type(::dg::RecognizeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizeParam.Type)
}

// optional .dg.RecognizeFunction Function = 2;
inline void RecognizeParam::clear_function() {
  function_ = 0;
}
inline ::dg::RecognizeFunction RecognizeParam::function() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeParam.Function)
  return static_cast< ::dg::RecognizeFunction >(function_);
}
inline void RecognizeParam::set_function(::dg::RecognizeFunction value) {
  
  function_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizeParam.Function)
}

// -------------------------------------------------------------------

// RecognizeRequest

// optional int64 SessionId = 1;
inline void RecognizeRequest::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RecognizeRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeRequest.SessionId)
  return sessionid_;
}
inline void RecognizeRequest::set_sessionid(::google::protobuf::int64 value) {
  
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizeRequest.SessionId)
}

// optional .dg.Image Image = 2;
inline bool RecognizeRequest::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
inline void RecognizeRequest::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::dg::Image& RecognizeRequest::image() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeRequest.Image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::dg::Image* RecognizeRequest::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::dg::Image;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeRequest.Image)
  return image_;
}
inline ::dg::Image* RecognizeRequest::release_image() {
  
  ::dg::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void RecognizeRequest::set_allocated_image(::dg::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeRequest.Image)
}

// optional .dg.RecognizeParam Param = 3;
inline bool RecognizeRequest::has_param() const {
  return !_is_default_instance_ && param_ != NULL;
}
inline void RecognizeRequest::clear_param() {
  if (GetArenaNoVirtual() == NULL && param_ != NULL) delete param_;
  param_ = NULL;
}
inline const ::dg::RecognizeParam& RecognizeRequest::param() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeRequest.Param)
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::dg::RecognizeParam* RecognizeRequest::mutable_param() {
  
  if (param_ == NULL) {
    param_ = new ::dg::RecognizeParam;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeRequest.Param)
  return param_;
}
inline ::dg::RecognizeParam* RecognizeRequest::release_param() {
  
  ::dg::RecognizeParam* temp = param_;
  param_ = NULL;
  return temp;
}
inline void RecognizeRequest::set_allocated_param(::dg::RecognizeParam* param) {
  delete param_;
  param_ = param;
  if (param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeRequest.Param)
}

// -------------------------------------------------------------------

// VehicleBrand

// optional int32 BrandId = 1;
inline void VehicleBrand::clear_brandid() {
  brandid_ = 0;
}
inline ::google::protobuf::int32 VehicleBrand::brandid() const {
  // @@protoc_insertion_point(field_get:dg.VehicleBrand.BrandId)
  return brandid_;
}
inline void VehicleBrand::set_brandid(::google::protobuf::int32 value) {
  
  brandid_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleBrand.BrandId)
}

// optional float Confidence = 2;
inline void VehicleBrand::clear_confidence() {
  confidence_ = 0;
}
inline float VehicleBrand::confidence() const {
  // @@protoc_insertion_point(field_get:dg.VehicleBrand.Confidence)
  return confidence_;
}
inline void VehicleBrand::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleBrand.Confidence)
}

// -------------------------------------------------------------------

// VehiclePlate

// optional .dg.Cutboard Box = 1;
inline bool VehiclePlate::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void VehiclePlate::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::dg::Cutboard& VehiclePlate::box() const {
  // @@protoc_insertion_point(field_get:dg.VehiclePlate.Box)
  return box_ != NULL ? *box_ : *default_instance_->box_;
}
inline ::dg::Cutboard* VehiclePlate::mutable_box() {
  
  if (box_ == NULL) {
    box_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.VehiclePlate.Box)
  return box_;
}
inline ::dg::Cutboard* VehiclePlate::release_box() {
  
  ::dg::Cutboard* temp = box_;
  box_ = NULL;
  return temp;
}
inline void VehiclePlate::set_allocated_box(::dg::Cutboard* box) {
  delete box_;
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.VehiclePlate.Box)
}

// optional int32 PlateType = 2;
inline void VehiclePlate::clear_platetype() {
  platetype_ = 0;
}
inline ::google::protobuf::int32 VehiclePlate::platetype() const {
  // @@protoc_insertion_point(field_get:dg.VehiclePlate.PlateType)
  return platetype_;
}
inline void VehiclePlate::set_platetype(::google::protobuf::int32 value) {
  
  platetype_ = value;
  // @@protoc_insertion_point(field_set:dg.VehiclePlate.PlateType)
}

// optional string PlateNum = 3;
inline void VehiclePlate::clear_platenum() {
  platenum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VehiclePlate::platenum() const {
  // @@protoc_insertion_point(field_get:dg.VehiclePlate.PlateNum)
  return platenum_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehiclePlate::set_platenum(const ::std::string& value) {
  
  platenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.VehiclePlate.PlateNum)
}
inline void VehiclePlate::set_platenum(const char* value) {
  
  platenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.VehiclePlate.PlateNum)
}
inline void VehiclePlate::set_platenum(const char* value, size_t size) {
  
  platenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.VehiclePlate.PlateNum)
}
inline ::std::string* VehiclePlate::mutable_platenum() {
  
  // @@protoc_insertion_point(field_mutable:dg.VehiclePlate.PlateNum)
  return platenum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehiclePlate::release_platenum() {
  
  return platenum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehiclePlate::set_allocated_platenum(::std::string* platenum) {
  if (platenum != NULL) {
    
  } else {
    
  }
  platenum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platenum);
  // @@protoc_insertion_point(field_set_allocated:dg.VehiclePlate.PlateNum)
}

// optional .dg.Color PlateColor = 4;
inline bool VehiclePlate::has_platecolor() const {
  return !_is_default_instance_ && platecolor_ != NULL;
}
inline void VehiclePlate::clear_platecolor() {
  if (GetArenaNoVirtual() == NULL && platecolor_ != NULL) delete platecolor_;
  platecolor_ = NULL;
}
inline const ::dg::Color& VehiclePlate::platecolor() const {
  // @@protoc_insertion_point(field_get:dg.VehiclePlate.PlateColor)
  return platecolor_ != NULL ? *platecolor_ : *default_instance_->platecolor_;
}
inline ::dg::Color* VehiclePlate::mutable_platecolor() {
  
  if (platecolor_ == NULL) {
    platecolor_ = new ::dg::Color;
  }
  // @@protoc_insertion_point(field_mutable:dg.VehiclePlate.PlateColor)
  return platecolor_;
}
inline ::dg::Color* VehiclePlate::release_platecolor() {
  
  ::dg::Color* temp = platecolor_;
  platecolor_ = NULL;
  return temp;
}
inline void VehiclePlate::set_allocated_platecolor(::dg::Color* platecolor) {
  delete platecolor_;
  platecolor_ = platecolor;
  if (platecolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.VehiclePlate.PlateColor)
}

// optional float Confidence = 5;
inline void VehiclePlate::clear_confidence() {
  confidence_ = 0;
}
inline float VehiclePlate::confidence() const {
  // @@protoc_insertion_point(field_get:dg.VehiclePlate.Confidence)
  return confidence_;
}
inline void VehiclePlate::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.VehiclePlate.Confidence)
}

// -------------------------------------------------------------------

// VehicleSymbol

// optional .dg.Cutboard Box = 1;
inline bool VehicleSymbol::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void VehicleSymbol::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::dg::Cutboard& VehicleSymbol::box() const {
  // @@protoc_insertion_point(field_get:dg.VehicleSymbol.Box)
  return box_ != NULL ? *box_ : *default_instance_->box_;
}
inline ::dg::Cutboard* VehicleSymbol::mutable_box() {
  
  if (box_ == NULL) {
    box_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.VehicleSymbol.Box)
  return box_;
}
inline ::dg::Cutboard* VehicleSymbol::release_box() {
  
  ::dg::Cutboard* temp = box_;
  box_ = NULL;
  return temp;
}
inline void VehicleSymbol::set_allocated_box(::dg::Cutboard* box) {
  delete box_;
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.VehicleSymbol.Box)
}

// optional int32 SymbolType = 2;
inline void VehicleSymbol::clear_symboltype() {
  symboltype_ = 0;
}
inline ::google::protobuf::int32 VehicleSymbol::symboltype() const {
  // @@protoc_insertion_point(field_get:dg.VehicleSymbol.SymbolType)
  return symboltype_;
}
inline void VehicleSymbol::set_symboltype(::google::protobuf::int32 value) {
  
  symboltype_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleSymbol.SymbolType)
}

// optional float Confidence = 3;
inline void VehicleSymbol::clear_confidence() {
  confidence_ = 0;
}
inline float VehicleSymbol::confidence() const {
  // @@protoc_insertion_point(field_get:dg.VehicleSymbol.Confidence)
  return confidence_;
}
inline void VehicleSymbol::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:dg.VehicleSymbol.Confidence)
}

// -------------------------------------------------------------------

// Feature

// optional bytes FeatureVector = 1;
inline void Feature::clear_featurevector() {
  featurevector_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Feature::featurevector() const {
  // @@protoc_insertion_point(field_get:dg.Feature.FeatureVector)
  return featurevector_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Feature::set_featurevector(const ::std::string& value) {
  
  featurevector_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dg.Feature.FeatureVector)
}
inline void Feature::set_featurevector(const char* value) {
  
  featurevector_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dg.Feature.FeatureVector)
}
inline void Feature::set_featurevector(const void* value, size_t size) {
  
  featurevector_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dg.Feature.FeatureVector)
}
inline ::std::string* Feature::mutable_featurevector() {
  
  // @@protoc_insertion_point(field_mutable:dg.Feature.FeatureVector)
  return featurevector_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Feature::release_featurevector() {
  
  return featurevector_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Feature::set_allocated_featurevector(::std::string* featurevector) {
  if (featurevector != NULL) {
    
  } else {
    
  }
  featurevector_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), featurevector);
  // @@protoc_insertion_point(field_set_allocated:dg.Feature.FeatureVector)
}

// -------------------------------------------------------------------

// RecognizeResult

// optional .dg.ObjType Type = 1;
inline void RecognizeResult::clear_type() {
  type_ = 0;
}
inline ::dg::ObjType RecognizeResult::type() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Type)
  return static_cast< ::dg::ObjType >(type_);
}
inline void RecognizeResult::set_type(::dg::ObjType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizeResult.Type)
}

// optional .dg.Cutboard Box = 2;
inline bool RecognizeResult::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void RecognizeResult::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::dg::Cutboard& RecognizeResult::box() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Box)
  return box_ != NULL ? *box_ : *default_instance_->box_;
}
inline ::dg::Cutboard* RecognizeResult::mutable_box() {
  
  if (box_ == NULL) {
    box_ = new ::dg::Cutboard;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResult.Box)
  return box_;
}
inline ::dg::Cutboard* RecognizeResult::release_box() {
  
  ::dg::Cutboard* temp = box_;
  box_ = NULL;
  return temp;
}
inline void RecognizeResult::set_allocated_box(::dg::Cutboard* box) {
  delete box_;
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResult.Box)
}

// optional .dg.VehicleBrand Brand = 3;
inline bool RecognizeResult::has_brand() const {
  return !_is_default_instance_ && brand_ != NULL;
}
inline void RecognizeResult::clear_brand() {
  if (GetArenaNoVirtual() == NULL && brand_ != NULL) delete brand_;
  brand_ = NULL;
}
inline const ::dg::VehicleBrand& RecognizeResult::brand() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Brand)
  return brand_ != NULL ? *brand_ : *default_instance_->brand_;
}
inline ::dg::VehicleBrand* RecognizeResult::mutable_brand() {
  
  if (brand_ == NULL) {
    brand_ = new ::dg::VehicleBrand;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResult.Brand)
  return brand_;
}
inline ::dg::VehicleBrand* RecognizeResult::release_brand() {
  
  ::dg::VehicleBrand* temp = brand_;
  brand_ = NULL;
  return temp;
}
inline void RecognizeResult::set_allocated_brand(::dg::VehicleBrand* brand) {
  delete brand_;
  brand_ = brand;
  if (brand) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResult.Brand)
}

// optional .dg.VehiclePlate Plate = 4;
inline bool RecognizeResult::has_plate() const {
  return !_is_default_instance_ && plate_ != NULL;
}
inline void RecognizeResult::clear_plate() {
  if (GetArenaNoVirtual() == NULL && plate_ != NULL) delete plate_;
  plate_ = NULL;
}
inline const ::dg::VehiclePlate& RecognizeResult::plate() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Plate)
  return plate_ != NULL ? *plate_ : *default_instance_->plate_;
}
inline ::dg::VehiclePlate* RecognizeResult::mutable_plate() {
  
  if (plate_ == NULL) {
    plate_ = new ::dg::VehiclePlate;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResult.Plate)
  return plate_;
}
inline ::dg::VehiclePlate* RecognizeResult::release_plate() {
  
  ::dg::VehiclePlate* temp = plate_;
  plate_ = NULL;
  return temp;
}
inline void RecognizeResult::set_allocated_plate(::dg::VehiclePlate* plate) {
  delete plate_;
  plate_ = plate;
  if (plate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResult.Plate)
}

// optional .dg.Color Color = 5;
inline bool RecognizeResult::has_color() const {
  return !_is_default_instance_ && color_ != NULL;
}
inline void RecognizeResult::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::dg::Color& RecognizeResult::color() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::dg::Color* RecognizeResult::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::dg::Color;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResult.Color)
  return color_;
}
inline ::dg::Color* RecognizeResult::release_color() {
  
  ::dg::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void RecognizeResult::set_allocated_color(::dg::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResult.Color)
}

// optional .dg.Feature Feature = 6;
inline bool RecognizeResult::has_feature() const {
  return !_is_default_instance_ && feature_ != NULL;
}
inline void RecognizeResult::clear_feature() {
  if (GetArenaNoVirtual() == NULL && feature_ != NULL) delete feature_;
  feature_ = NULL;
}
inline const ::dg::Feature& RecognizeResult::feature() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Feature)
  return feature_ != NULL ? *feature_ : *default_instance_->feature_;
}
inline ::dg::Feature* RecognizeResult::mutable_feature() {
  
  if (feature_ == NULL) {
    feature_ = new ::dg::Feature;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResult.Feature)
  return feature_;
}
inline ::dg::Feature* RecognizeResult::release_feature() {
  
  ::dg::Feature* temp = feature_;
  feature_ = NULL;
  return temp;
}
inline void RecognizeResult::set_allocated_feature(::dg::Feature* feature) {
  delete feature_;
  feature_ = feature;
  if (feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResult.Feature)
}

// repeated .dg.VehicleSymbol Symbols = 7;
inline int RecognizeResult::symbols_size() const {
  return symbols_.size();
}
inline void RecognizeResult::clear_symbols() {
  symbols_.Clear();
}
inline const ::dg::VehicleSymbol& RecognizeResult::symbols(int index) const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResult.Symbols)
  return symbols_.Get(index);
}
inline ::dg::VehicleSymbol* RecognizeResult::mutable_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResult.Symbols)
  return symbols_.Mutable(index);
}
inline ::dg::VehicleSymbol* RecognizeResult::add_symbols() {
  // @@protoc_insertion_point(field_add:dg.RecognizeResult.Symbols)
  return symbols_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::VehicleSymbol >*
RecognizeResult::mutable_symbols() {
  // @@protoc_insertion_point(field_mutable_list:dg.RecognizeResult.Symbols)
  return &symbols_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::VehicleSymbol >&
RecognizeResult::symbols() const {
  // @@protoc_insertion_point(field_list:dg.RecognizeResult.Symbols)
  return symbols_;
}

// -------------------------------------------------------------------

// RecognizeResponse

// optional int64 SessionId = 1;
inline void RecognizeResponse::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RecognizeResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResponse.SessionId)
  return sessionid_;
}
inline void RecognizeResponse::set_sessionid(::google::protobuf::int64 value) {
  
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:dg.RecognizeResponse.SessionId)
}

// optional .dg.RecognizeStatus Status = 2;
inline bool RecognizeResponse::has_status() const {
  return !_is_default_instance_ && status_ != NULL;
}
inline void RecognizeResponse::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) delete status_;
  status_ = NULL;
}
inline const ::dg::RecognizeStatus& RecognizeResponse::status() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResponse.Status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::dg::RecognizeStatus* RecognizeResponse::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::dg::RecognizeStatus;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResponse.Status)
  return status_;
}
inline ::dg::RecognizeStatus* RecognizeResponse::release_status() {
  
  ::dg::RecognizeStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void RecognizeResponse::set_allocated_status(::dg::RecognizeStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResponse.Status)
}

// optional .dg.RecognizeResult Result = 3;
inline bool RecognizeResponse::has_result() const {
  return !_is_default_instance_ && result_ != NULL;
}
inline void RecognizeResponse::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) delete result_;
  result_ = NULL;
}
inline const ::dg::RecognizeResult& RecognizeResponse::result() const {
  // @@protoc_insertion_point(field_get:dg.RecognizeResponse.Result)
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::dg::RecognizeResult* RecognizeResponse::mutable_result() {
  
  if (result_ == NULL) {
    result_ = new ::dg::RecognizeResult;
  }
  // @@protoc_insertion_point(field_mutable:dg.RecognizeResponse.Result)
  return result_;
}
inline ::dg::RecognizeResult* RecognizeResponse::release_result() {
  
  ::dg::RecognizeResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void RecognizeResponse::set_allocated_result(::dg::RecognizeResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dg.RecognizeResponse.Result)
}

// -------------------------------------------------------------------

// BatchRecognizeRequest

// repeated .dg.RecognizeRequest Requests = 1;
inline int BatchRecognizeRequest::requests_size() const {
  return requests_.size();
}
inline void BatchRecognizeRequest::clear_requests() {
  requests_.Clear();
}
inline const ::dg::RecognizeRequest& BatchRecognizeRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:dg.BatchRecognizeRequest.Requests)
  return requests_.Get(index);
}
inline ::dg::RecognizeRequest* BatchRecognizeRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:dg.BatchRecognizeRequest.Requests)
  return requests_.Mutable(index);
}
inline ::dg::RecognizeRequest* BatchRecognizeRequest::add_requests() {
  // @@protoc_insertion_point(field_add:dg.BatchRecognizeRequest.Requests)
  return requests_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::RecognizeRequest >*
BatchRecognizeRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:dg.BatchRecognizeRequest.Requests)
  return &requests_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::RecognizeRequest >&
BatchRecognizeRequest::requests() const {
  // @@protoc_insertion_point(field_list:dg.BatchRecognizeRequest.Requests)
  return requests_;
}

// -------------------------------------------------------------------

// BatchRecognizeResponse

// repeated .dg.RecognizeResponse Reponses = 1;
inline int BatchRecognizeResponse::reponses_size() const {
  return reponses_.size();
}
inline void BatchRecognizeResponse::clear_reponses() {
  reponses_.Clear();
}
inline const ::dg::RecognizeResponse& BatchRecognizeResponse::reponses(int index) const {
  // @@protoc_insertion_point(field_get:dg.BatchRecognizeResponse.Reponses)
  return reponses_.Get(index);
}
inline ::dg::RecognizeResponse* BatchRecognizeResponse::mutable_reponses(int index) {
  // @@protoc_insertion_point(field_mutable:dg.BatchRecognizeResponse.Reponses)
  return reponses_.Mutable(index);
}
inline ::dg::RecognizeResponse* BatchRecognizeResponse::add_reponses() {
  // @@protoc_insertion_point(field_add:dg.BatchRecognizeResponse.Reponses)
  return reponses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dg::RecognizeResponse >*
BatchRecognizeResponse::mutable_reponses() {
  // @@protoc_insertion_point(field_mutable_list:dg.BatchRecognizeResponse.Reponses)
  return &reponses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dg::RecognizeResponse >&
BatchRecognizeResponse::reponses() const {
  // @@protoc_insertion_point(field_list:dg.BatchRecognizeResponse.Reponses)
  return reponses_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dg::RecognizeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dg::RecognizeType>() {
  return ::dg::RecognizeType_descriptor();
}
template <> struct is_proto_enum< ::dg::RecognizeFunction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dg::RecognizeFunction>() {
  return ::dg::RecognizeFunction_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_witness_2eproto__INCLUDED
